Die Typen seien in einer Bibliothek $\text{L}$ in folgender Form zusammengefasst:
\begin{table}[H]
\centering
\begin{tabular}{|p{6cm}|p{10cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Erläuterung} \\
\hline
\hline
$L ::= TD\text{*}$ & Eine Bibliothek \emph{L} besteht aus einer Menge von Typdefinitionen.\\
\hline
$TD ::= PD | RD$ & Eine Typdefinition kann entweder die Definition eines provided Typen (PD) oder eines required Typen (RD) sein.\\
\hline
$PD ::=$ provided T extends T' $\{ FD\text{*} MD\text{*}\}$& Die Definition eines provided Typen besteht aus dem Namen des Typen \emph{T}, dem Namen des Super-Typs \emph{T'} von \emph{T} sowie mehreren Feld- und Methodendeklarationen.\\
\hline
$RD ::=$ required T $\{MD\text{*}\}$ & Die Definition eines required Typen besteht aus dem Namen des Typen \emph{T} sowie mehreren Methodendeklarationen.\\
\hline
$FD ::=$ f : T & Eine Felddeklaration besteht aus dem Namen des Feldes \emph{f} und dem Namen seines Typs \emph{T}.\\
\hline
$MD ::=$ m(T):T' & Eine Methodendeklaration besteht aus dem Namen der Methode \emph{m}, dem Namen des Parameter-Typs \emph{T} und dem Namen des Rückgabe-Typs \emph{T'}.\\
\hline
\hline
\end{tabular}
\caption{Grammatik für die Definition einer Bibliothek von Typen}
 \label{tab:eIShort}
\end{table}
\noindent
Weiterhin sei die Relation $<$ auf Typen durch folgenden Regel definiert:
\begin{eqnarray*}
T < T' := \text{provided \emph{T} extends \emph{T'}} \in L \vee (\text{provided \emph{T} extends \emph{T''}} \in L \wedge T'' < T') 
\end{eqnarray*}
Darüber hinaus seien folgende Funktionen definiert:
\begin{gather*}
felder(T) :=  \left\{ 
				\begin{array}{l|l}
					f : T' & \text{ \emph{f : T'} ist Felddeklaration von \emph{T}}
				\end{array}
              \right\}\\
methoden(T) := \left\{ 
				\begin{array}{l|l}
					m(T'):T'' & \text{ \emph{m(T'):T''} ist Methodendeklaration von 										\emph{T}}
				\end{array}
              \right\}\\
vererbteMethoden(T,T') := \left\{
                \begin{array}{l|l}
                	  		&	T<T' \wedge m(P):R\in methoden(T) \wedge \\
					m(P):R 	& 	\exists m(P'):R'\in methoden(T').\\
							&	(P<P' \vee P=P') \wedge (R>R' \vee R=R') 
                \end{array}
              \right\}
\end{gather*}
\noindent
Das Matching eines Typs $A$ zu einem Typ $B$ wird durch die Funktion $match(A,B)$ beschrieben. Dabei wird $A$ auch als \emph{Source-Typ} und $B$ als \emph{Target-Typ} bezeichnet.\\\\
Ein Proxy beschreibt die Konvertierung einer Menge von Target-Typen $P = \{T_1, ..., T_n\}$ in einen Proxy-Typen $S$. Die Definition eines Proxies hat dabei folgende Form:
\begin{table}[H]
\centering
\begin{tabular}{|p{6cm}|p{8cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Erläuterung} \\
\hline
\hline
$PROXY ::=$\newline proxy P extends T $\{TARGET\text{*}\}$ & Eine Proxy-Definition besteht aus dem Namen des Proxy-Typs \emph{P}, dem Namen des Super-Typs \emph{T} des Proxies sowie einer Mengen von Targets, die die Basis für den Proxy bilden. \\
\hline
$TDEL ::=$\newline T target $\{MDEL\text{*} AZ\text{*}\}$ & Die Definition einer Targets besteht aus dem Namen des Target-Typs \emph{T}, dem Namen einer Variablen \emph{target} zur Referenzierung des Target-Objektes, sowie einer Menge aus Methodendelegationen und Attributzuweisungen.\\
\hline
$AZ ::=$ f = $TR$& Eine Attributzuweisung besteht aus dem Namen des Attributfeldes des Proxies \emph{f} und einer Targetreferenz.\\
\hline
$MDEL ::= CALLM \rightarrow DELT $  & Eine Methodendelegation besteht aus einer Methode, die auf dem Proxy aufgerufen wird (CALLM) und einem Delegationsziel (DELT), an das der Aufruf delegiert wird.\\
\hline
$CALLM ::=$\newline $m(P) : TYPECONV $  & Eine aufgerufene Methode besteht aus ihrem Namen \emph{m}, dem Namen des Parametertyps \emph{P} und einem Konverter für den Rückgabetyp. \\
\hline
$DELT ::=$\newline $TR.n(TYPECONV) : R $  & Ein Delegationsziel besteht aus einer Referenz auf das Delegationsobjekt (TR), dem Methodennamen \emph{n} der am Delegationsobjekt aufzurufenden Methoden, sowie einem Konverter Parametertyp und dem Namen des Rückgabetype \emph{R} der Methode \emph{n}.\\
\hline
$TYPECONV ::= PROXY | T$  & Ein Konverter ist entweder wiederum ein Proxy, oder ein Typ T, sofern keine Konvertierung vorgenommen wird.\\
\hline
$TR ::=$\newline $target | target.f $ & Eine Targetreferenz ist entweder die Variable für das Target-Objekt (\emph{target}) oder ein Feld mit dem Namen \emph{f} des Target.Objektes.\\
\hline
\hline
\end{tabular}
\caption{Grammatik für die Definition eines Proxies}
 \label{tab:eIShort}
\end{table}
\noindent
Zusätzlich seien folgenden Funktionen definiert:
\begin{gather*}
targets(X) := \left\{ 
				\begin{array}{l|l}
					T 	& \text{\emph{T} ist der Name des Typs einer}\\
						& \text{Targets von \emph{X}}
				\end{array}
              \right\}\\       
delegationen(X,T) := \left\{
                \begin{array}{l|l}
m(SP):SR & m(SP):SR \rightarrow target.n(TP):TR\\
\rightarrow	& \text{ist eine Methodendelegation eines }\\
					target.n(TP):TR & \text{Targets \emph{T} mit } T \in targets(X) 
                \end{array}
              \right\}\\
zuweisungen(X,T) := \left\{
                \begin{array}{l|l}
                	f = V 	& 	f = V\text{ ist eine Attributzuweisung eines} \\
                	& \text{Targets \emph{T} mit } T \in targets(X)\\
				\end{array}
              \right\}
\end{gather*}
\noindent

%---------------------------------------------------\\\\
%\abbref{} stellt den Ablauf einer Delegation der Methode mit dem Namen \emph{s} innerhalb eines Proxies an eine Methode \emph{t} des Target-Objektes dar. Dabei wird der Parameter \emph{ps} der Methode \emph{s} in ein Objekt vom Typ \emph{TP} konvertiert. Nachdem durch die Methode \emph{t} das Objekt \emph{tr} zurückgegeben wurde, wird dieses wiederum in ein Objekt vom Typ \emph{SR} konvertiert.

%Unter der Annahme, dass die Funktion $Proxy(S,P)$ einen Proxy $X$ in der o.g. Form mit $S$ als Proxy-Typ und $targets(X)=P$ beschreibt, sieht die dazugehörige Methodendelegation sieht wie folgt aus:
%\begin{gather*}
%	source.s(sp):sr \rightarrow target.t(Proxy(TP,\{type(sp)\})):Proxy(SR,\{type(tr)\})
%\end{gather*}

%Darüber hinaus gelten für die Methodendelegationen folgende Regeln:

%---------------------------------------------------\\\\

\subsubsection{StructuralTypeMatcher}\label{structTypeMatcher}
Ein Ziel dieser Arbeit ist es Typen, die keinerlei Assoziationen zueinander habe, miteinander zu matchen und so zu konvertieren, dass darauf aufbauend die erwartete Semantik überprüfen werden kann. Hierfür soll wie auch in \cite{hummel08} die strukturelle Übereinstimmung der beiden Typen genutzt werden. Diesem Zweck dient der StructuralTypeMatcher.
\myparagraph{Szenario}
Um die grundlegenden Eigenschaften des StructuralTypeMatchers darzustellen, wird von einem Szenario ausgegangen, in dem zwei \emph{provided Interfaces} in Kombination ein \emph{required Interface} erfüllen. Dabei wird von einer Bibliothek $L$ ausgegangen, die zum einen eine Erweiterung der Typen aus dem JDK um die in \lstref{struct_scerantio_bib} definierten Typen darstellt.
\begin{figure}[H]
\begin{minipage}[b]{.45\linewidth}
  \begin{lstlisting}
provided Injured extends Object{
	void heal()	
}
\end{lstlisting}


\begin{lstlisting}
provided Fire extends Object{
	void extinguish()
}
\end{lstlisting}


\begin{lstlisting}
provided FireFighter extends Object{}
\end{lstlisting}

\end{minipage}%
\hspace{.04\linewidth}% Abstand zwischen Bilder
\begin{minipage}[b]{.51\linewidth}


\begin{lstlisting}
provided Doctor extends Object{	
	void intubate( Patient patient )
}
\end{lstlisting}

\begin{lstlisting}
provided Patient extends Injured{
	boolean isStable()
}
\end{lstlisting}

\begin{lstlisting}
required IntubatingFireFither {
	void intubate( Injured injured )
	void extinguishFire( Fire fire )	
}
\end{lstlisting}
\end{minipage}
\end{figure}
\noindent
Durch den StructuralTypeMatcher soll zum einen ein Matching der Form $\matchTyp{IntubatingFireFighter}{}{FireFighter}$ und $\matchTyp{IntubatingFireFighter}{}{Doctor}$ ermittelt werden. Darüber hinaus soll die Kombination aus $FireFighter$ und $Doctor$ in den Typ $IntubatingFireFither$ konvertiert werden. Ein Proxy $PTF$ der aus der Konvertierung der Typen $FireFighter$ und $Doctor$ in den Typ $IntubatingFireFighter$ ist in \lstref{struct_proxy} beschrieben.
\begin{lstlisting}
proxy PTF extends IntubationFireFighter{
	FireFighter fireFighter {
		extinguishFire(Fire):void --> fireFighter.extinguishFire(Fire):void		
	}
		
	Doctor doctor {
		intubate(Injured):void --> doctor.intubate(
			proxy PPatient extends Patient{
				Injured injured{
					heal():void --> injured.heal():void			
				}		
			}):void		
	}
}
\end{lstlisting}
\abbref{methodDelegation_IntubatingFireFighter} zeigt, wie die Delegation der Aufrufe der Methoden des Typs $IntubatingFireFighter$ durch die o.g. Proxy-Definition erfolgen.\\\\
Dabei wird beim Aufruf der Methoden \emph{extinguishFire(Fire)} an die Methoden \emph{extinguishFire(Fire)} des Typs $FireFighter$ delegiert. Dabei wird der Parameter vom Typ $Fire$ einfach weitergereicht, ohne dass eine Konvertierung des Parameters ist in diesem Fall nicht notwendig, da der Parameter-Typ der aufgerufenen Methode und der Methode, an die der Aufruf delegiert wird, identisch sind. Dasselbe gilt für die Rückgabewerte der beiden Methoden.\\\\
Der Aufruf der Methode \emph{intubate(Injured)} wird an die Methode \emph{intubate(Patient)} des Typs $Doctor$ delegiert. Dabei erfolgt eine weitere Konvertierung des Typs $Injured$ in den Typ $Patient$.

\myparagraph{Definition}
Das strukturelle Matching zwischen einem \emph{required Interface} $R$ und einem \emph{provided Interface} $P$ ist gegeben, sofern eine Methode aus $R$ zu einer Methode aus $P$ gematcht werden kann. Die Menge der gematchten Methoden aus $R$ und $P$ wird wie folgt beschrieben:
\begin{gather*}
structM(R,P) := \left\{ 
				\begin{array}{l|l}
					m(T):T' \in methoden(R)	& \exists n(S):S' \in methoden(P) .\\													&  \matchTyp{S}{egsc}{T} \wedge \matchTyp{T'}{egsc}{S'}
				\end{array}
              \right\}
\end{gather*}
Da die Notation es nicht hergibt, ist zusätzlich zu erwähnen, dass die Reihenfolge der Parameter in $m$ und $n$ irrelevant ist.\\\\
Die Funktion $\matchTyp{A}{egsc}{B}$ wird durch die übrigen Matcher in folgender Form beschrieben:
\begin{gather*}
\frac{\splitfrac{\matchTyp{A}{exact}{B} \wedge \matchTyp{A}{spec}{B} 
\wedge \matchTyp{A}{gen}{B}}{\wedge \matchTyp{A}{container}{B} \wedge \matchTyp{A}{content}{B}}}{\matchTyp{A}{egsc}{B}}
\end{gather*}
Das strukturelle Matching von $R$ und $P$ wird dann durch folgende Regel beschrieben. 
\begin{matcherEquivDef}{StructuralTypeMatcher}
\frac{structM(R,P) \neq \emptyset}{\matchTyp{R}{struct}{P}}
\end{matcherEquivDef}
Für die Verwendung von $R$ muss jedoch sichergestellt werden, dass alle darin enthaltenen Methoden durch ein oder mehrere \emph{required Interfaces} innerhalb der gesamten Bibliothek $L$ gematcht werden. Folgende Funktion beschreibt daher eine Menge von \emph{provided Interfaces}, die in Kombination zu allen Methoden von $R$ eine übereinstimmende Methode enthalten.
\begin{gather*}
cover(R,L) := \left\{ 
				\begin{array}{l|l}
					\{P_1,...,P_n\}	& P_1 \in L \wedge \text{...} \wedge P_n \in L \wedge \\
									& structM(R,P_1) \cup \text{...} \cup structM(R, P_n) = methoden(R)
				\end{array}
              \right\}
\end{gather*}
Für $R$ kann die Exploration abgebrochen werden, wenn $cover(R,L) = \emptyset$ gilt.\\\\
Die Menge aller Konvertierungsmöglichkeiten einer Menge von \emph{provided Interfaces} $P = \{P_1,...,P_n\}$ in ein \emph{required Interface} $R$ über den StrucutralTypeMatcher wird durch die Funktion $Proxy_{struct}(R,P)$ beschrieben. Dazu sei $singleMDEL(X, MDEL)$ für einen Proxy $X$ und eine Methodendelegation $MDEL$ durch folgende Regel beschrieben.

\begin{gather*}
\frac{\splitfrac{\forall T \in targets(X).[\exists MDEL \rightarrow N \in delegationen(X,T) \wedge}{ \forall T' \in targets(X).(MDEL \rightarrow N) \not\in delegationen(X,T') \vee T' = T]}}{singleMDEL(X, MDEL)}
\end{gather*}



\begin{matcherConvDef}{StructuralTypeMatcher}{
Die Menge von Proxies, die eine Konvertierung einer Menge von \emph{provided Interfaces} $P = \{P_1,...,P_n\}$ in ein \emph{required Interface} $R$ beschreiben, wird durch die folgenden Funktion definiert:}
Proxy_{struct}(R,P) := \left\{ 
				\begin{array}{l|l}
		& \forall T \in targets(X).[zuweisungen(R,T) = \emptyset \wedge T \in P \wedge \\
		& \forall (m(SP):SR \rightarrow target.n(TP):TR) \in delegationen(X,T).[ \\
	X	& SR \in Proxy_{esgc}(SR,TR) \wedge TP \in Proxy_{esgc}(TP,SP)\\
		& \wedge m(SP):SR \in methoden(R) \wedge n(TP):TR \in methoden(T) \\
		& \wedge singleMDEL(X, m(SP):SR)]]
				\end{array}
              \right\}
\end{matcherConvDef}\\
Für einen Proxy $X \in Proxy_{esgc}(A,B)$ gilt:
\begin{gather*}
Proxy_{esgc}(A,B) = \begin{array}{l}Proxy_{exact}(A,B) \cup Proxy_{spec}(A,B) \cup Proxy_{gen}(A,B)\\
 \cup Proxy_{container}(A,B) \cup Proxy_{content}(A,B)
 \end{array}
\end{gather*}

\subsubsection{ExactTypeMatcher}\label{exactTypeMatcher}
\myparagraph{Szenario}
Dieser Matcher stellt das Matching zweier identischer Typen fest. Das Matching kann erfolgt somit auf nominaler Ebene erfolgen.
\myparagraph{Definition}
\begin{matcherEquivDef}{ExactTypeMatcher}
\frac{}{\matchTyp{T}{exact}{T}}
\end{matcherEquivDef}
\begin{matcherConvDef}{ExactTypeMatcher}{
Eine Konvertierung eines Typs $T$ in denselben Typ ist praktisch nicht notwendig. Daher gilt:}
Proxy_{exact}(T,T) = \{T\}
\end{matcherConvDef}

\subsubsection{GenTypeMatcher}\label{genTypeMatcher}
\myparagraph{Szenario}
Dieser Matcher stellt das Matching zwischen zwei Typen her, die in einer Vererbungsbeziehung stehen. Speziell erlaubt dieser Matcher das Matching eines Supertyps als \emph{Source-Typ} mit einem Subtyp als \emph{Target-Typ}. Ausgehend von den Typen aus \lstref{example_library} wird für dieses Szenario auf die Typen $Injured$ als Supertyp und $Patient$ als Subtyp zurückgegriffen. Der GenTypeMatcher soll in diesem Fall ein Matching der Form $\matchTyp{Injured}{gen}{Patient}$ festellen. In \abbref{} ist schematisch dargestellt, wie eine Methode, die auf dem Supertyp $Injured$ aufgerufen wird, an eine Methode des Subtyps $Patient$ delegiert wird. Eine solche Delegation wird aufgrund der Regeln für die Methoden-Deklarationen innerhalb von Sub- und Supertypen ohne Zuhilfenahme eines Proxies erreicht.\footnote{Die Parameter-Typen müssen Kovarianz und die Rückgabe-Typen Kontravarianz aufweisen. Folglich ist eine Delegation wie in \abbref{} aufgrund des Substitutionsprinzips möglich.}
Daher muss keine Konvertierung des \emph{Target-Typs} in den \emph{Source-Typ} erfolgen. Vielmehr kann der \emph{Target-Typ} überall dort eingesetzt werden, wo der \emph{Super-Typ erwartet wird.}
\myparagraph{Definition}
\begin{matcherEquivDef}{GenTypeMatcher}
\frac{B < A}{\matchTyp{A}{gen}{B}}
\end{matcherEquivDef}
\begin{matcherConvDef}{GenTypeMatcher}{
Für zwei Typen $A$ und $B$ für die $\matchTyp{A}{gen}{B}$ gilt, ist keine Konvertierung von $B$ in $A$ notwendig. Somit gilt:}
Proxy_{gen}(A,B) = \{B\}
\end{matcherConvDef}
\subsubsection{SpecTypeMatcher}\label{specTypeMatcher}
\myparagraph{Szenario}
Analog zum GenTypeMatcher stellt der SpecTypeMatcher ebenfalls das Matching zwischen Typen fest, die in einer Vererbungsbeziehung stehen. Allerdings soll durch diesen Matcher der umgekehrte Fall abgebildet werden.
Demnach soll ausgehend von den Typen $Injured$ als Supertyp und $Patient$ als Subtyp aus \lstref{example_library}  ein Matching der Form $\matchTyp{AccidentVictim}{spec}{Injured}$ ermittelt werden. Eine Verwendung des Typen $Injured$ anstelle von $Patient$ ist nicht ohne Konvertierung möglich. Daher als Resultat der Konvertierung über diesen Matcher ein Proxytyp $PPatient$ erwartet, der \lstref{} entnommen werden kann.
\begin{lstlisting}
proxy PPatient extends Patient{
	Injured injured {
		heal():void --> injured.heal():void	
	}		
}		
\end{lstlisting}
Bei genauerer Betrachtung des \emph{provided Interfaces} $Patient$ und $Injured$ fällt auf, dass der Subtyp $Patient$ eine eigenen Methode deklariert. Bei einer Konvertierung kann diese Methode nicht delegiert werden. Der Aufruf würde dementsprechend fehlschlagen.\footnote{Downcast}
In \abbref{} und \abbref{} sind die Methodenaufrufe der beiden angebotenen Methoden des Typs $PPatient$ mit ihrer Delegation bzw. Fehlschlag aufgeführt. 
\myparagraph{Definition}
\begin{matcherEquivDef}{SpecTypeMatcher}
\frac{\inhTyp{A}{B}}{\matchTyp{A}{spec}{B}}
\end{matcherEquivDef}
\begin{matcherConvDef}{SpecTypeMatcher}{
Für zwei Typen $A$ und $B$ für die $\matchTyp{A}{spec}{B}$ ist die Menge an möglichen Proxytypen wie folgt definiert:}
Proxy_{spec}(A,B) := \left\{ 
				\begin{array}{l|l}
  & targets(X) = \{B\} \wedge zuweisungen(X,B) = \emptyset \wedge \\
X & \forall m(P):R \in vererbteMethoden(A,B).\\						  & \exists m(P):R \rightarrow target.m(P):R \in delegationen(X,B)
				\end{array}
              \right\}
\end{matcherConvDef}
\subsubsection{ContentTypeMatcher}\label{contentTypeMatcher}
\myparagraph{Szenario}
In \ref{Hum8}

Die bisherigen Type-Matcher sind in der Lage das Matching für zwei Typen festzustellen, ohne dafür Rücksicht auf deren innere Struktur nehmen zu müssen. Dies ist für identische oder hierarchisch organisierte Typen auch nicht notwendig. Es ist jedoch auch denkbar, dass sich beiden Typen auf anderem Wegen assoziieren lassen. Ein Beispiel dafür wäre Boxed- bzw. - noch allgemeiner gefasst - Wrapper-Typen. In \abbref{cd_subclass_subwrapper} sind zwei Klassen dargestellt, die in einer solchen Beziehung zueinander stehen. Bezüglich des Matchings sind auch hier wiederum zwei Fälle zu unterscheiden. Der erste Fall, in dem das Matching des Source-Typen SubClass mit dem Typen eines Attributs wrapped des Traget-Typen SubWrapper festgestellt werden kann, ist in \abbref{sd_wrapped_sub2subwrapped} dargestellt.
\begin{figure}[H]
\begin{minipage}[b]{.33\linewidth}
  \centering
  \includegraphics[width=\linewidth]{cd_subclass_subwrapper}
  \caption{Beziehung zwischen SubClass und SubWrapper}
  \label{abb:cd_subclass_subwrapper}

\end{minipage}%
\hspace{.04\linewidth}% Abstand zwischen Bilder
\begin{minipage}[b]{.63\linewidth}


  \centering
  \includegraphics[width=\linewidth]{sd_wrapped_sub2subwrapped}
  \caption{Szenario WrappedTypeMatcher}
  \label{abb:sd_wrapped_sub2subwrapped}

\end{minipage}
\end{figure}
\noindent
Der WrappedTypeMatcher stellt das Matching für ein solches Szenario fest. Das Matching der beiden Typen beruht letztendlich auf einem Matching zwischen dem Source-Type und dem Typen eines Attributs des Target-Typs. Der Matcher, über den dieses Matching innerhalb des WrappedTypeMatchers festgestellt wird, wird als interner Matcher bezeichnet. In dem Szenario aus \abbref{sd_wrapped_sub2subwrapped} wird als interner Matcher der bereits beschriebene ExactTypeMatcher verwendet, weil der Source-Type und der Typ des Attributs wrapped identisch sind.
\myparagraph{Definition}
\begin{matcherEquivDef}{WrappedTypeMatcher}
\matchTyp{A}{wrapped}{B} \text{ wenn } \exists \selTyp{B}{attr} : \matchTyp{A}{M}{attr}
\end{matcherEquivDef}\\
Der zuvor genannte interne Matcher wird in der Definition mit $M$ beschrieben, was stellvertretend für eine Menge von Matchern steht. Als interne Matcher kommen hierbei der ExactTypeMatcher, der GenTypeMatcher und der SpecTypeMatcher in Frage.\\
\begin{matcherConvDef}{WrappedTypeMatcher}{
Sei $m$ eine Methode des Typs $A$. Sei weiterhin $B$ ein Typ, der ein Attribut vom Typ $attr$ enthält, für den gilt $\matchTyp{A}{M}{attr}$.
}
\delegate{A.m}{(\applyMatcher{A}{attr}).m}
\end{matcherConvDef}\\
Ein Beispiel für die Verwendung des Matchers in Bezug auf das o.g. Szenario ist in \appref{wrappedMatcherExample} zu finden. Außerdem sind dort auch weitere Szenarien aufgefüht, in denen der GenTypeMatcher oder der SpecTypeMatcher als interner Matcher zur Anwendung kommen.


\subsubsection{WrapperTypeMatcher}\label{wrapperTypeMatcher}
\myparagraph{Szenario}
Dieser Matcher stellt das Pendant zum WrappedTypeMatcher dar. Der Unterschied bzgl. des Szenarios besteht darin, dass nun der Source-Typ derjenige ist, der ein Attribut enthält, für dessen Typ ein Matching zum Target-Typen über den ExactTypeMatcher, den GenTypeMatcher oder den SpecTypeMatcher festgestellt werden kann. Für das Szenario ist wiederum von den Typen aus \abbref{cd_subclass_subwrapper} auszugehen. Die Delegation der möglichen Methodenaufrufe am Source-Typen, sind in \abbref{sd_wrapper_subwrapped2sub} abgebildet. Hierbei ist hervorzuheben, dass zur Laufzeit das Objekt vom Target-Typen in das Attribut des Objektes vom Source-Typen injiziert wird. Dies soll in \abbref{sd_wrapper_subwrapped2sub} durch die Bezeichnung des Targets mit wrapped (dem Namen des Attributs) und target dargestellt werden. Eine Methoden-Delegation findet nur dann statt, wenn sie auch im Wrapper-Typen (Source-Typen) implementiert wurde\footnote{Implementierung von SubWrapper: siehe \appref{matcherExamples} \lstref{LST_subwrapper_impl}}.
\myScalableFigure[0.8\linewidth]{sd_wrapper_subwrapped2sub}{Szenario WrapperTypeMatcher}{sd_wrapper_subwrapped2sub}
\myparagraph{Definition}
\begin{matcherEquivDef}{WrapperTypeMatcher}
\matchTyp{A}{wrapper}{B} \text{ wenn } \exists\selTyp{A}{attr} : \matchTyp{B}{M}{attr} 
\end{matcherEquivDef}\\
Wie an dieser Beschreibung zu erkennen ist, werden auch hier wieder ein interner Matcher $M$ verwendet. Analog zum WrappedTypeMatcher kommen auch hier der ExactTypeMatcher, der GenTypeMatcher und der SpecTypeMatcher in Frage.\\
\begin{matcherConvDef}{WrappedTypeMatcher}{
Sei $m$ eine Methode des Typs $A$.
}
\delegate{A.m}{A.m}
\end{matcherConvDef}\\
Ein Beispiel für die Verwendung des Matchers in Bezug auf das o.g. Szenario ist in \appref{wrapperMatcherExample} zu finden. Außerdem sind dort auch weitere Szenarien aufgefüht, in denen der GenTypeMatcher oder der SpecTypeMatcher als interner Matcher zur Anwendung kommen.



\subsection{1. Stufe - Strukturelle Übereinstimmung}
Wie in \cite{hummel08} wird in der ersten Stufe der Suche versucht die angebotenen Interfaces herauszusuchen, die strukturell mit dem erwarteten Interface übereinstimmen. Zu diesem Zweck wird ein Type-Matcher verwendet, der in Abschnitt \ref{structTypeMatcher} beschrieben wird. Darüber hinaus werden weitere Type-Matcher verwendet (siehe Abschnitte \refs{exactTypeMatcher}{wrapperTypeMatcher}), die das Matching zweier Typen auf der Basis der Beziehung, in der diese beiden Typen zueinander stehen, feststellen. Allgemein beschrieben, kann durch jeden dieser Type-Matcher festgestellt werden, ob sich ein Typ in einen anderen Typ konvertieren lässt.\\\\
Die Konvertierung erfolgt zur Laufzeit über Proxies, die ihre Methodenaufrufe delegieren. So wird bspw. bei der Konvertierung eines Objektes von TypA in ein Objekt von TypB ein Proxy-Objekt für TypB erzeugt, welches die Methodenaufrufe auf dem Objekt von TypA delegiert (vgl. \abbref{combinated_components}).\\\\
Hummel hatte hierzu bereits auf einige Matcher von Zaremski und Wing \cite{moormann} zurückgegriffen, die in dieser Arbeit ebenfalls zum Einsatz kommen (siehe Abschnitte \refs{exactTypeMatcher}{specTypeMatcher}). Weiterhin wurde in \cite{hummel08} ein Anwendungsfall für einen Matcher skizziert, der in der Lage ist Wrapper-Typen zu Matcher. Aus diese Idee wird in den Abschnitten \ref{wrappedTypeMatcher} und \ref{wrapperTypeMatcher} zurückgegriffen. Die Definitionen der Matcher beziehen sich vorrangig auf die Programmiersprache Java, weshalb grundlegend von einer nominalen Typkonformität auszugehen ist.
\input{matcher}
\input{type_conv_variant}
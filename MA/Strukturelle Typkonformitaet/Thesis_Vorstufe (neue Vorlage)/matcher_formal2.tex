Die Typen seien in einer Bibliothek $\text{L}$ in folgender Form zusammengefasst:
\begin{table}[H]
\centering
\begin{tabular}{|p{6cm}|p{10cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Erläuterung} \\
\hline
\hline
$L ::= TD\text{*}$ & Eine Bibliothek \emph{L} besteht aus einer Menge von Typdefinitionen.\\
\hline
$TD ::= PD | RD$ & Eine Typdefinition kann entweder die Definition eines provided Typen (PD) oder eines required Typen (RD) sein.\\
\hline
$PD ::=$ provided T extends T' $\{ FD\text{*} MD\text{*}\}$& Die Definition eines provided Typen besteht aus dem Namen des Typen \emph{T}, dem Namen des Super-Typs \emph{T'} von \emph{T} sowie mehreren Feld- und Methodendeklarationen.\\
\hline
$RD ::=$ required T $\{MD\text{*}\}$ & Die Definition eines required Typen besteht aus dem Namen des Typen \emph{T} sowie mehreren Methodendeklarationen.\\
\hline
$FD ::=$ f : T & Eine Felddeklaration besteht aus dem Namen des Feldes \emph{f} und dem Namen seines Typs \emph{T}.\\
\hline
$MD ::=$ m(T):T' & Eine Methodendeklaration besteht aus dem Namen der Methode \emph{m}, dem Namen des Parameter-Typs \emph{T} und dem Namen des Rückgabe-Typs \emph{T'}.\\
\hline
\hline
\end{tabular}
\caption{Struktur für die Definition einer Bibliothek von Typen}
 \label{tab:eIShort}
\end{table}
\noindent
Weiterhin sei die Relation $<$ auf Typen durch folgenden Regel definiert:
\begin{eqnarray*}
T < T' := \text{provided \emph{T} extends \emph{T'}} \in L \vee (\text{provided \emph{T} extends \emph{T''}} \in L \wedge T'' < T') 
\end{eqnarray*}
Darüber hinaus seien folgende Funktionen definiert:
\begin{gather*}
felder(T) :=  \left\{ 
				\begin{array}{l|l}
					f : T' & \text{ \emph{f : T'} ist Felddeklaration von \emph{T}}
				\end{array}
              \right\}\\
methoden(T) := \left\{ 
				\begin{array}{l|l}
					m(T'):T'' & \text{ \emph{m(T'):T''} ist Methodendeklaration von 										\emph{T}}
				\end{array}
              \right\}\}
\end{gather*}
\noindent
Das Matching eines Typs $A$ zu einem Typ $B$ wird durch die asymmetrische Relation $\matchTyp{A}{}{B}$ beschrieben. Dabei wird $A$ auch als \emph{Source-Typ} und $B$ als \emph{Target-Typ} bezeichnet.\\\\
%Ein Proxy beschreibt die Konvertierung einer Menge von Target-Typen $P = \{T_1, ..., T_n\}$ in einen Proxy-Typen $X$. Die Definition eines Proxies hat dabei folgende Form:
Ein Proxy wird über die folgende Struktur beschrieben:
\begin{table}[H]
\centering
\begin{tabular}{|p{6cm}|p{8cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Erläuterung} \\
\hline
\hline
$\mathit{STRUCTPROXY} ::=$\newline $\texttt{structproxy } \texttt{for } R$\newline$ \texttt{\{}TARGET\texttt{*\}}$ & Ein struktureller Proxy wird für ein \emph{required Interface R} mit einer Mengen von Targets erzeugt.  \\
\hline
$\mathit{TARGET} ::=$\newline $P \texttt{ \{}MDEL\texttt{*\}}$ & Ein Target besteht aus dem Typ \emph{P} des Targets (ein \emph{provided Interface}) und einer Mengen von Methodendelegationen.\\
\hline
$\mathit{MDEL} ::= CALLM \rightarrow DELM $  & Eine Methodendelegation besteht aus einer aufgerufenen Methode und aus einem Delegationsziel.\\
\hline
$\mathit{CALLM} ::=$\newline $m(SP):STPROXY $  & Eine aufgerufene Methode besteht aus dem Namen der Methode \emph{m}, dem Parametertyp \emph{SP} und einem Single-Target-Proxy zur Konvertierung des Rückgabetyps des Delegationsziels.\\
\hline
$\mathit{DELM} ::=$\newline $n(STPROXY):R $  & Ein Delegationsziel besteht aus demdem Namen der Methode \emph{n}, dem Rückgabetyp \emph{TR} und einem Single-Target-Proxy zur Konvertierung des Parametertyps der aufgerufenen Methode.\\
\hline
$\mathit{STPROXY} ::= NPX$ & Ein Nominal-Proxy ist ein Single-Target-Proxy.\\
\hline
$\mathit{STPROXY} ::=$\newline $\texttt{contentproxy }  \texttt{for } P$\newline $\texttt{with } P' \texttt{ \{}CEMDEL\texttt{*\}}$ & Ein Content-Proxy ist ein Single-Target-Proxy, der für ein \emph{provided Interface P} mit einem \emph{provided Interface P'} als Target-Typ sowie einer Mengen von Content-Proxy-Methodendelegationen erzeugt wird.\\
\hline
$\mathit{STPROXY} ::=$\newline $\texttt{containerproxy} \texttt{ for } P$\newline
$ \texttt{with } P' \texttt{ \{} f = \mathit{NPX} \texttt{\}}$ &  Ein Container-Proxy ist ein Single-Target-Proxy, der für ein \emph{provided Interface P} mit einem \emph{provided Interface P'} als Target-Typ sowie der Zuweisung eines Nominal-Proxies für den Target-Typ zu einem Feld \emph{f} erzeugt wird.\\

\hline
\end{tabular}
\caption{Struktur für die Definition eines Proxies}
 \label{tab:eIShort}
\end{table}
\newpage
\begin{table}[H]
\centering
\begin{tabular}{|p{6cm}|p{8cm}|}
\hline
\centering\textbf{Regel} & \textbf{Erläuterung} \\
\hline
\hline
$\mathit{NPX} ::=$ \newline $\texttt{subproxy } \texttt{for } P$\newline $\texttt{with } P' \texttt{ \{}\mathit{NOMMDEL}\texttt{*\}}$ & Ein Sub-Proxy ist ein Nominal-Proxy, derfür ein \emph{provided Interface P} mit einem \emph{provided Interface P'} als Target-Typ sowie einer Mengen von Nominal-Proxy-Methodendelegationen erzeugt wird. Dabei gilt $P < P'$.\\
\hline
$\mathit{NPX} ::=$ \newline $\texttt{simpleproxy } \texttt{for } P$ & Ein Simple-Proxy ist ein Nominal-Proxy, der aus einem Typen \emph{P}, für den der Proxy erzeugt wird, besteht. Der Target-Typ ist in diesem Fall ebenfalls \emph{P}. Alle Methoden werden in diesem Fall an den Target-Typ delegiert.\\
\hline
$\mathit{NOMMDEL} ::=$\newline
$\mathit{m(SP):SR} \rightarrow \mathit{m(TP):TR} $  & Eine Nominal-Proxy-Methodendelegation besteht aus zwei Methoden mit demselben Namen \emph{m} und den jeweiligen Parameter- und Rückgabetypen \emph{SP} und \emph{SR} bzw. \emph{TP} und \emph{TR}. \\
\hline
$\mathit{CEMDEL} ::= \mathit{m(SP):NPX} \rightarrow$\newline
$\mathit{f.m(NPX):TR} $  & Eine Content-Proxy-Methodendelegation besteht aus zwei Methoden mit demselben Namen \emph{m}, wobei die delegierte Methode (rechte Seite) auf einem Feld \emph{f} des Target-Typs aufgerufen wird. Dabei besteht die aufgerufene Methode aus dem Parametertyp \emph{SP} und einem Nominal-Proxy für den Rückgabetyp. Ferner besteht die delegierte Methode aus dem jeweiligen Rückgabetyp \emph{TR} und einem Nominal-Proxy für den Parametertyp.\\
\hline
\hline
\end{tabular}
\caption{Struktur für die Definition eines Proxies (Fortsetzung)}
 \label{tab:eIShort}
\end{table}
Ein Ziel dieser Arbeit ist es Typen, die keinerlei Assoziationen zueinander haben, miteinander zu matchen und so zu konvertieren, dass darauf aufbauend die erwartete Semantik überprüfen werden kann. Hierfür soll wie auch in \cite{hummel08} die strukturelle Übereinstimmung der beiden Typen genutzt werden. Diesem Zweck dient der StructuralTypeMatcher.\\\\
Um ein Beispiel für ein solches Matching und die daran anschließende Konvertierung zu geben, sei von folgender Bibliothek von Typen auszugehen:

\begin{lstlisting}[style = dsl]
provided Fire extends Object{}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided FireState extends Object{
	isActive : boolean
}
\end{lstlisting}

 \begin{lstlisting}[style = dsl]
provided Medicine extends Object{
	String getDescription()
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided Injured extends Object{
	void heal(Medicine med)	
}
\end{lstlisting}


\begin{lstlisting}[style = dsl]
provided Patient extends Injured{}
\end{lstlisting}
\begin{lstlisting}[style = dsl]
provided FireFighter extends Object{
	FireState extinguishFire(Fire fire)
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided Doctor extends Object{	
	void heal( Patient pat, Medicine med )
}
\end{lstlisting}



\begin{lstlisting}[style = dsl]
provided MedCabinet extends Object{
	med : Medicine
}
\end{lstlisting}

\begin{lstlisting}[caption={Bibliothek von Typen},captionpos=b, style = dsl]
required MedicalFireFighter {
	void heal( Injured injured, MedCabinet med )
	boolean extinguishFire( Fire fire )	
}
\end{lstlisting}
Ein Proxy für das \emph{required Interface} $MedicalFireFighter$ könnte in diesem Szenario folgende Struktur aufweisen:
\begin{lstlisting}[caption={Proxy für MedicalFireFighter},captionpos=b,style = dsl]
structproxy for MedicalFireFither{
	FireFighter {
	 extinguishFire(Fire): 
	 	containerproxy for FireState with boolean {
		 isActive = simpleproxy for boolean		
		} 
		--> extinguishFire(simpleproxy for Fire):boolean
	}
		
	Doctor {
	 heal(Injured, MedCabinet):simpleproxy for void
		--> heal(subproxy for Patient with Injured{
			heal(Medicine):	void
				--> heal(Medicine):void					
		   }, contentproxy for Medicine with MedCabinet{
			getDescription(): simpleproxy for String
				--> med.getDescription():String			
		      }):void		
	}
}
\end{lstlisting}

Um die Regeln für das Matching und der darauf aufbauenden Konvertierung zu beschreiben, seien unterschiedliche Matcher definiert.
\subsubsection{StructuralTypeMatcher}\label{structTypeMatcher}
\subsection*{StructuralTypeMatcher}
Das strukturelle Matching zwischen einem \emph{required Interface} $R$ und einem \emph{provided Interface} $P$ ist gegeben, sofern eine Methode aus $R$ zu einer Methode aus $P$ gematcht werden kann. Die Menge der aus $R$ in $P$ gematchten Methoden wird wie folgt beschrieben:
\begin{gather*}
structM(R,P) := \left\{ 
				\begin{array}{l|l}
					m(T):T' \in methoden(R)	& \exists n(S):S' \in methoden(P) .\\													&  S\Rightarrow_{egsc} \wedge T' \Rightarrow_{egsc}S'
				\end{array}
              \right\}
\end{gather*}
Da die Notation es nicht hergibt, ist zusätzlich zu erwähnen, dass die Reihenfolge der Parameter in $m$ und $n$ irrelevant ist.\\\\
Die Relation $\Rightarrow_{egsc}$ wird durch die übrigen Matcher in folgender Form beschrieben:
\begin{gather*}
\frac{\splitfrac{A \Rightarrow_{exact}B \vee A \Rightarrow_{spec}B 
\vee A \Rightarrow_{gen}B}{\vee A \Rightarrow_{container} B \vee A \Rightarrow_{content} B}}{A \Rightarrow_{egsc}B}
\end{gather*}
Das strukturelle Matching von $R$ und $P$ wird dann durch folgende Regel beschrieben.

\begin{gather*}
\frac{structM(R,P) \neq \emptyset}{R \Rightarrow_{struct}P}
\end{gather*}
Ein struktureller Proxy für ein \emph{required Interface} $R$ aus einer Menge von \emph{provided Interfaces} $P$ wird durch folgende Regeln und Nebenbedingungen beschrieben:
\begin{table}[H]
\centering
\begin{tabular}{|p{4cm}|p{10cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Nebenbedingungen} \\
\hline
\hline
$\mathit{STRUCTPROXY} ::=$\newline $\texttt{structproxy } \texttt{for } R$\newline$ \texttt{\{}TARGET_1 \texttt{ ... }$ \newline
$ TARGET_n\texttt{\}}$ & $typ(\mathit{STRUCTPROXY})=R$\newline
$methoden(\mathit{STRUCTPROXY}) = $\newline
 $\mathit{cmethoden(TARGET_1)} \cup \texttt{...} \cup \mathit{cmethoden(TARGET_n)} $\newline
$methoden(R) = methoden(\mathit{STRUCTPROXY})$\\
\hline
$\mathit{TARGET} ::=$\newline $P \texttt{ \{}MDEL_1 \texttt{ ...}$\newline
$ MDEL_n\texttt{\}}$ &
$\mathit{typ(TARGET)} = P$ \newline
$\mathit{cmethoden(TARGET)} = $\newline
 $\mathit{cmethode(MDEL_1)} \cup \texttt{...} \cup \mathit{cmethode(MDEL_n)}$ \newline
$\mathit{dmethoden(TARGET)} =  $\newline 
 $\mathit{dmethode(MDEL_1)} \cup \texttt{...} \cup \mathit{dmethode(MDEL_n)}$ \newline
 $\mathit{dmethoden(TARGET)} \subseteq \mathit{methoden(P)} $ \\
\hline
$\mathit{MDEL} ::= $\newline
$ CALLM \rightarrow DELM $  & 
$\mathit{cmethode(MDEL}) = \mathit{methode(CALLM)}$\newline
$\mathit{dmethode(MDEL}) = \mathit{methode(DELM)}$\newline
$\mathit{paramTargetTyp(DELM)} = \mathit{paramTyp(CALLM)}$\newline
$\mathit{returnTargetTyp(CALLM)} = \mathit{returnTyp(DELM)}$
\\
\hline
$\mathit{CALLM} ::=$\newline $m(SP):STPROXY $  &
$SR = \mathit{typ(STPROXY)} $\newline
$\mathit{methode(CALLM)} = \mathit{m(SP):SR} $\newline
$\mathit{paramTyp(CALLM) = SP}$\newline
$\mathit{targetTyp(STPROXY) = returnTargetTyp(CALLM)}$ \\
\hline
$\mathit{DELM} ::=$\newline $n(STPROXY):R $  & 
$DP = \mathit{typ(STPROXY)} $\newline
$\mathit{methode(DELM)} = \mathit{n(DP):R} $\newline
$\mathit{returnTyp(DELM) = R}$\newline
$\mathit{targetTyp(STPROXY) = paramTargetTyp(DELM)}$ \\
\hline
\hline
\end{tabular}
\caption{Grammatik für die Definition eines Proxies}
 \label{tab:eIShort}
\end{table}
\noindent
Regeln für das Nonterminal \emph{STPROXY} unterliegen Nebenbedingungen, die teilweise erst unter Zuhilfenahme der folgenden Matcher erfüllt werden können.
\subsection*{ExactTypeMatcher}
Die Matchingrelation für diesen Matcher wird durch folgende Regel beschrieben:

\begin{gather*}
\frac{}{T \Rightarrow_{exact} T}
\end{gather*}
Ein Proxy für einen Typ $T$, der mit demselben Typ als Target-Typ erzeugt werden soll, ist ein Simple-Proxy. Die Regeln für den Simple-Proxy, sind im folgenden Abschnitt zum \emph{GenTypeMatcher} beschrieben.


\subsection*{GenTypeMatcher}
Die Matchingrelation für diesen Matcher wird durch folgende Regel beschrieben:
\begin{gather*}
\frac{T > T'}{T \Rightarrow_{gen} T'}
\end{gather*}
Ein Proxy für einen Typ $T$, der mit einem Typen-Typ $T'$ mit $T \Rightarrow_{gen} T'$ erzeugt werden soll, ist ein Simple-Proxy und wird über die folgenden Regeln und Nebenbedingungen beschrieben:

\begin{table}[H]
\centering
\begin{tabular}{|p{4cm}|p{10cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Nebenbedingungen} \\
\hline
\hline
$\mathit{STPROXY} ::= NPX$ &
$\mathit{typ(STPROXY)}=\mathit{typ(NPX)}$\newline
$\mathit{targetTyp(STPROXY)} = \mathit{targetTyp(NPX)}$\\
\hline
$\mathit{NPX} ::=$ \newline $\texttt{simpleproxy } \texttt{for } P$ & 
$\mathit{targetTyp(NPX)} \Rightarrow_{gen} P $\newline
$\mathit{typ(NPX)}=P$\newline
$\mathit{methoden(NPX)} = \mathit{methoden(P)}$
\\
\hline
\hline
\end{tabular}
\caption{Regeln und Nebenbedingungen für Simple-Proxies}
 \label{tab:simp}
\end{table}

\subsection*{SpecTypeMatcher}
Die Matchingrelation für diesen Matcher wird durch folgende Regel beschrieben:
\begin{gather*}
\frac{T < T'}{T \Rightarrow_{spec} T'}
\end{gather*}
Ein Proxy für einen Typ $T$, der mit einem Target-Typ $T'$ mit $T \Rightarrow_{spec} T'$ erzeugt werden soll, ist ein Sub-Proxy und wird durch die folgenden Regeln und Nebenbedingungen beschrieben: 
\begin{table}[H]
\centering
\begin{tabular}{|p{5cm}|p{9cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Nebenbedingungen} \\
\hline
\hline
$\mathit{NPX} ::=$ \newline $\texttt{subproxy } \texttt{for } P$\newline $\texttt{with } P' \texttt{ \{}\mathit{NOMMDEL_1}$\newline
$ \texttt{... }\mathit{NOMMDEL_n}\texttt{\}}$ & 
$\mathit{targetTyp(NPX)} = P'$\newline
$\mathit{typ(NPX)} = P$\newline
$P \Rightarrow_{spec} P'$\newline
$\mathit{methoden(NPX)} = \mathit{cmethode(NOMMDEL_1)} \cup $\newline
$\texttt{...} \cup \mathit{cmethode(NOMMDEL_n)}$ \newline
$\mathit{methoden(NPX)} \subseteq \mathit{methoden(P)}  $\newline 
$\mathit{methoden(P')} \supseteq \mathit{dmethode(NOMMDEL_1)} \cup  $\newline 
$\texttt{...} \cup \mathit{dmethode(NOMMDEL_n)}$ 
\\
\hline
$\mathit{NOMMDEL} ::=$\newline
$\mathit{m(SP):SR} \rightarrow$\newline
$ \mathit{m(TP):TR} $  &
$SP >= TP$\newline
$SR <= TR$\newline
$\mathit{cmethode(MOMMDEL)} = \mathit{m(SP):SR}$\newline
$\mathit{dmethode(MOMMDEL)} = \mathit{m(TP):TR}$ \\
\hline
\hline
\end{tabular}
\caption{Regeln und Nebenbedingungen für Sub-Proxies}
 \label{tab:simp}
\end{table}
\subsection*{ContentTypeMatcher}
Die Matchingrelation für diesen Matcher wird durch folgende Regel beschrieben:
\begin{gather*}
\frac{\exists f:T''\in felder(T'). T \Rightarrow_{esg} T''}{T \Rightarrow_{content} T'}
\end{gather*}
Für die Relation $\Rightarrow_{esg}$ gilt dabei:
\begin{gather*}
\frac{T \Rightarrow_{exact} T' \vee T \Rightarrow_{gen} T' \vee
T \Rightarrow_{spec} T'  }{T \Rightarrow_{esg} T'}
\end{gather*}
Ein Proxy für einen Typ $P$, der mit einem Target-Typ $P'$ mit $P \Rightarrow_{content} P'$ erzeugt werden soll, ist ein Content-Proxy und wird durch die folgenden Regeln und Nebenbedingungen beschrieben:
\begin{table}[H]
\centering
\begin{tabular}{|p{4cm}|p{10cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Nebenbedingungen} \\
\hline
\hline
$\mathit{STPROXY} ::=$\newline $\texttt{contentproxy }  \texttt{for } P$\newline $\texttt{with } P' \texttt{ \{}CEMDEL_1$\newline
$\texttt{... } CEMDEL_n\texttt{\}}$ &
$\mathit{typ(STPROXY)}= P$\newline
$\mathit{targetTyp(STPROXY)}= P'$\newline
$P \Rightarrow_{content} P'$\newline
$\mathit{methoden(STPROXY)} = \mathit{cmethode(CEMDEL_1)} \cup $\newline
$\texttt{...} \cup \mathit{cmethode(CEMDEL_n)}$ \newline
$\mathit{methoden(STPROXY)} \subseteq \mathit{methoden(P)}  $\newline
$\mathit{containerType(CEMDEL_1)} = P'$ \newline
$ \texttt{... } \mathit{containerType(CEMDEL_n)} = P' $ \\
\hline
$\mathit{CEMDEL} ::=$\newline
$\mathit{CECALLM} \rightarrow$\newline
$\mathit{f.CEDELM} $  &
$\mathit{f:FT} \in \mathit{felder(containerType(CEMDEL))}$ \newline
$\mathit{methode(CEDELM)} \in \mathit{methoden(FT)} $\newline
$\mathit{paramTargetTyp(CEDELM)} = \mathit{paramTyp(CECALLM)}$\newline
$\mathit{returnTargetTyp(CECALLM)} = \mathit{returnTyp(CEDELM)}$\\
\hline
$\mathit{CECALLM} ::=$\newline
$\mathit{m(SP):NPX} $  &
$\mathit{paramTyp(CECALLM)} = \mathit{SP}$\newline
$SR = \mathit{typ(NPX)}$\newline
$\mathit{targetTyp(NPX)} = \mathit{returnTargetTyp(CECALLM)}$\newline
$\mathit{methode(CECALLM)} = \mathit{m(SP):SR}$\\
\hline
$\mathit{CEDELM} ::=$\newline
$\mathit{m(NPX):TR} $  &
$\mathit{returnTyp(CEDELM)} = \mathit{TR} $\newline
$\mathit{TP} = \mathit{typ(NPX)} $\newline
$\mathit{targetTyp(NPX)} = \mathit{paramTargetTyp(CEDELM)} $\newline
$\mathit{methode(CEDELM)} =\mathit{m(TP):TR} $\\
\hline
\hline
\end{tabular}
\caption{Regeln und Nebenbedingungen für Contentproxies}
 \label{tab:simp}
\end{table}

\subsection*{ContainerTypeMatcher}
Die Matchingrelation für diesen Matcher wird durch folgende Regel beschrieben:
\begin{gather*}
\frac{\exists f:T''\in felder(T). T'' \Rightarrow_{esg} T'}{T \Rightarrow_{container} T'}
\end{gather*}
Ein Proxy für einen Typ $P$, der mit einem Target-Typ $P'$ mit $P \Rightarrow_{container} P'$ erzeugt werden soll, ist ein Container-Proxy und wird durch die folgenden Regeln und Nebenbedingungen beschrieben:
\begin{table}[H]
\centering
\begin{tabular}{|p{6cm}|p{8cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Nebenbedingungen} \\
\hline
\hline
$\mathit{STPROXY} ::=$\newline $\texttt{containerproxy} \texttt{ for } P$\newline
$ \texttt{with } P' \texttt{ \{} f = \mathit{NPX} \texttt{\}}$ & 
$\mathit{targetTyp(STPROXY)} = P'$\newline
$\mathit{typ(STPROXY)} = P$\newline
$P \Rightarrow_{container} P'$\newline
$\mathit{f:FT} \in \mathit{felder(P)}$\newline
$\mathit{targetTyp(NPX)} = P'$\newline
$\mathit{typ(NPX)} = FT$\\
\hline
\hline
\end{tabular}
\caption{Regeln und Nebenbedingungen für Container-Proxies}
 \label{tab:simp}
\end{table}



\chapter{Verwendung aller Heuristiken}\label{app_semEvalMitAllenHeuristiken}
Die in den Abschnitten \ref{sec_lmf} - \ref{sec_bl_nmc} vorgestellten \Gls{Heuristik}en können miteinander kombiniert werden. Listing \ref{lst_heuristikkombination} zeigt die Implementierung der Funktionen, die für diese Kombination auf der Basis von Listing \ref{lst_semEval} angepasst oder ergänzt werden müssen.

\begin{lstlisting}[style = pseudo, caption = Kombination aller Heuristiken, captionpos = b, label = lst_heuristikkombination]
function evalProxiesMitTarget( proxies, tests ){
 testedProxies = []
 for( proxy : proxies ){
  passedTestcases = 0
  blacklistChanged = false
  evalProxy(proxy, tests)
  if( passedTests == T.size ){
   return proxy
  }
  else{
   testedProxies.add(proxy)
   if( passedTests > 0 || blacklistChanged ){
    optmizedProxies = proxies.removeAll( testedProxies )
    if( passedTests > 0 ){
     priorityTargets.addAll( proxy.targets )
     optmizedProxies = PTTF( optmizedProxies )	
    }
    if( blacklistChanged ){
     optmizedProxies = BL( optmizedProxies )	
    }
    return evalProxiesMitTarget( optmizedProxies, tests )
   }
  }
 }
 return null
}

function evalProxy(proxy, tests){
 for( test : tests ){
  try{
   if( test.eval( proxy ) ){
    passedTestcases = passedTestcases + 1
   }
   elseif( test.isSingleMethodTest ){
    methodName = test.testedSingleMethodName
    mDel = getMethodDelegation( proxy, methodName )
    methodDelegationBlacklist.add( mDel )
    blacklistChanged = true
    return
   }
  }
  catch (SigMaGlueException e){
   mDel = e.failedMethodDelegation
   methodDelegationBlacklist.add( mDel )
   blacklistChanged = true
   return
  } 
 }
}

function relevantProxies( proxies, anzahl ){
 relProxies = proxiesMitTargets( proxies, anzahl );
 optimizedLMF = LMF( relProxies )
 optimizedPTTF = PTTF( optimizedLMF )
 return BL( optimizedPTTF )
} 
\end{lstlisting}
\section{Strukturelle Evaluation}
In Anlehnung an \cite{hummel08} werden die \emph{EJBs} auf der Basis des Signature-Matching Ansatzes ermittelt. Dieser Ansatz wurde ursprünglich von Zaremski und Wing \cite{moormann} beschrieben. Er basiert darauf, dass lediglich die Methoden-Signaturen der Typen (Klassen bzw. Interfaces) miteinander abgeglichen (gematcht) werden. 
\\\\
Zu diesem Zweck wird eine Struktur zur Deklaration von Typen in Abschnitt \ref{sec:strukturTypen} vorgegeben, die eine abstrakte Darstellung der Klassen bzw. Interfaces, darstellen. Darüber hinaus werden in diesem Abschnitt Eigenschaften der Typen sowie Funktionen vorgestellt, die für den weiteren Verlauf der Arbeit von Belang sind.
\\\\
Der Abgleich der Signaturen dieser Typen erfolgt in \cite{moormann} auf der Basis von Matchern. Die in dieser Arbeit verwendeten Matcher werden in Abschnitt \ref{sec_matcher} genauer beschrieben. Einige der dort beschriebenen Matcher basieren auf denen aus \cite{moormann}. Andere basieren auf Überlegungen aus \cite{hummel08}.
\subsection{Struktur für die Definition von Typen}\label{sec:strukturTypen}
Die Typen werden in einer Bibliothek $\text{L}$ in folgender Form deklariert:
\begin{table}[H]
\centering
\begin{tabular}{|p{5.5cm}|p{8.5cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Erläuterung} \\
\hline
\hline
$\mathit{L} ::= \mathit{TD}\text{*}$ & Eine Bibliothek \emph{L} besteht aus einer Menge von Typdefinitionen.\\
\hline
$\mathit{TD} ::= \mathit{PD} | \mathit{RD}$ & Eine Typdefinition kann entweder die Definition eines provided Typen (PD) oder eines required Typen (RD) sein.\\
\hline
$\mathit{PD} ::= \newline\texttt{provided }T \texttt{ extends } T' \newline  \texttt{\{} \mathit{FD}\text{*} \mathit{MD}\text{*}\texttt{\}}$& Die Definition eines provided Typen besteht aus dem Namen des Typen \emph{T}, dem Namen des Super-Typs \emph{T'} von \emph{T} sowie mehreren Feld- und Methodendeklarationen.\\
\hline
$\mathit{RD} ::= \texttt{required } T \texttt{ \{}\mathit{MD}\text{*}\texttt{\}}$ & Die Definition eines required Typen besteht aus dem Namen des Typen \emph{T} sowie mehreren Methodendeklarationen.\\
\hline
$\mathit{FD} ::= T \texttt{ }\mathit{f}$ & Eine Felddeklaration besteht aus dem Namen des Feldes \emph{f} und dem Namen seines Typs \emph{T}.\\
\hline
$\mathit{MD} ::= \mathit{T'}\texttt{ }\mathit{m(T_1,...,T_n)}$ & Eine Methodendeklaration besteht aus dem Namen der Methode \emph{m}, $n$ Namen der Parameter-Typen $T_1$ bis $T_n$ und dem Namen des Rückgabe-Typs \emph{T'}.\\
\hline
\hline
\end{tabular}
\caption{Struktur für die Definition einer Bibliothek von Typen}
 \label{tab_typeStruct}
\end{table}
\noindent
Zudem sei die Relation $<$ auf Typen durch folgende Regeln definiert:
\begin{gather*}
\frac{\texttt{provided }T \texttt{ extends } T' \in L}{T < T'}
\end{gather*}
\begin{gather*}
\frac{\texttt{provided } T \texttt{ extends } T'' \in L \wedge T'' < T'}{T < T'}
\end{gather*}
\noindent
Darüber hinaus seien folgende Funktionen definiert:
\begin{gather*}
\mathit{felder(T)} :=  \left\{ 
				\begin{array}{l|l}
					T \texttt{ }\mathit{f} & T \texttt{ }\mathit{f}\text{ ist Felddeklaration von }T
				\end{array}
              \right\}
\\
\mathit{feldTyp(f,T)} := 
				\begin{array}{l|l}
					T' & T' \texttt{ }\mathit{f}\text{ ist Felddeklaration von }T
				\end{array}   
\\
\mathit{ret(T'\text{ }m(T''_1,...T''_n))} := T'
\\
\mathit{params(T''\text{ }m(T'_1,...T'_n))} := \{ T'_1,...,T'_n \}
\\   
\mathit{methoden(T)} := \left\{ 
				\begin{array}{l|l}
					T'' \text{ }m(T'_1,...,T'_n) & T'' \text{ }m(T'_1,...,T'_n) \text{ ist Methodendeklaration von }T
				\end{array}
              \right\}
\\        
\end{gather*}
\noindent
Listing \ref{lst:libEx} zeigt ein Beispiel für eine Bibilothek mit \emph{required} und \emph{provided Typen}.
\begin{lstlisting}[style = dsl]
provided Fire extends Object{}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided ExtFire extends Fire{}
\end{lstlisting}


\begin{lstlisting}[style = dsl]
provided FireState extends Object{
	boolean isActive
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided Medicine extends Object{
	String getDescription()
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided Injured extends Object{
	void heal(Medicine med)	
}
\end{lstlisting}


\begin{lstlisting}[style = dsl]
provided Patient extends Injured{
	String getName()
}
\end{lstlisting}
\begin{lstlisting}[style = dsl]
provided FireFighter extends Object{
	FireState extinguishFire(Fire fire)
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided Doctor extends Object{	
	void heal( Patient pat, Medicine med )
}
\end{lstlisting}


\begin{lstlisting}[style = dsl]
provided InverseDoctor extends Object{	
	void heal( Medicine med, Patient pat )
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided MedCabinet extends Object{
	Medicine med
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
required PatientMedicalFireFighter {
	void heal( Patient patient, MedCabinet med )
	boolean extinguishFire( ExtFire fire )	
}
\end{lstlisting}

\begin{lstlisting}[caption={Bibliothek \emph{ExampLe} von Typen},captionpos=b, style = dsl, label=lst:libEx]
required MedicalFireFighter {
	void heal( Injured injured, MedCabinet med )
	boolean extinguishFire( ExtFire fire )	
}
\end{lstlisting}
\noindent
\subsection{Definition der Matchern}\label{sec_matcher}
Ein Matcher definiert das Matching eines Typs $T$ zu einem Typ $T'$ durch die asymmetrische Relation $\Rightarrow$ (auch Matchingrealtion genannt)\footnote{$T \Rightarrow T'$}.
\subsubsection{ExactTypeMatcher}\label{sec:exacttypematcher}
Der \emph{ExactTypeMatcher} stellt ein Matching von einem Typ $T$ zu demselben Typ $T$ her (vgl. \cite{moormann}). Die dazugehörige Matchingrelation $\Rightarrow_{exact}$ wird durch folgende Regel beschrieben:
\begin{gather*}
\frac{}{T \Rightarrow_{exact} T}
\end{gather*}
\subsubsection{GenTypeMatcher}\label{sec:gentypematcher}
Der \emph{GenTypeMatcher} stellt ein Matching von einem Typ $T$ zu einem Typ $T'$ mit $T > T'$ her (vgl. \cite{moormann}). Die dazugehörige Matchingrelation $\Rightarrow_{gen}$ wird durch folgende Regel beschrieben:
\begin{gather*}
\frac{T > T'}{T \Rightarrow_{gen} T'}
\end{gather*}
\paragraph{SpecTypeMatcher}
Der \emph{SpecTypeMatcher} stellt im Verhältnis zum \emph{GenTypeMatcher} das Matching in die entgegengesetzte Richtung dar (vgl. \cite{moormann}). Die dazugehörige Matchingrelation $\Rightarrow_{spec}$ wird durch folgende Regel beschrieben: 
\begin{gather*}
\frac{T < T'}{T \Rightarrow_{spec} T'}
\end{gather*}
\\\\
Die oben genannten Matchingrelationen werden für die Definition weiterer Matcher zusammengefasst, wodurch sich die Matchingrelation $\Rightarrow_{internCont}$ ergibt:
\begin{gather*}
\frac{T \Rightarrow_{exact} T' \vee T \Rightarrow_{gen} T' \vee
T \Rightarrow_{spec} T'  }{T \Rightarrow_{internCont} T'}
\end{gather*}
\noindent
\\\\
Die folgenden Matcher matchen so genannte Wrapper-Typen mit den Typen der in ihnen enthaltenen Attribute. Die Idee für solche Matcher fand in \cite{hummel08} zwar Erwähnung jedoch erfolgte dort keine formale Beschreibung. Ziel dieser Matcher ist es bspw. die Typen $\texttt{boolean}$ und $\texttt{FireState}$ aus Listing \ref{lst:libEx} zu matchen.
\subsubsection{ContentTypeMatcher}
Der \emph{ContentTypeMatcher} matcht einen Typ $T$ auf einen Typ $T'$, wobei $T'$ ein Feld enthält, auf dessen Typ $T''$ der Typ $T$ über die Matchingrelation $\Rightarrow_{internCont}$ gematcht werden kann.
\\\\
Die dazugehörige Matchingrelation $\Rightarrow_{content}$ wird durch folgende Regel beschrieben:
\begin{gather*}
\frac{\exists \mathit{T''\text{ }f}\in felder(T'): T \Rightarrow_{internCont} T''}{T \Rightarrow_{content} T'}
\end{gather*}
\noindent
So würde für die Typen $\texttt{boolean}$ und $\texttt{FireState}$ gelten: 
\begin{gather*}
\texttt{boolean} \Rightarrow_{content} \texttt{FireState}
\end{gather*}
\subsubsection{ContainerTypeMatcher}
Der \emph{ContainerTypeMatcher} stellt im Verhältnis zum \emph{ContentTypeMatcher} das Matching in die entgegengesetzte Richtung dar.
\\\\
Die dazugehörige Matchingrelation $\Rightarrow_{container}$ wird durch folgende Regel beschrieben:
\begin{gather*}
\frac{\exists \mathit{T''\text{ }f}\in felder(T): T'' \Rightarrow_{internCont} T'}{T \Rightarrow_{container} T'}
\end{gather*}
\noindent
So gilt für die Typen $\texttt{FireState}$ und $\texttt{boolean}$: 
\begin{gather*}
\texttt{FireState} \Rightarrow_{container} \texttt{boolean}
\end{gather*}
\\\\
Zur Definition des letzten Matchers werden die Matchingrelationen der oben genannten Matcher noch einmal zusammengefasst. Dabei entsteht die Matchingrelation $\Rightarrow_{internStruct}$, welche durch folgende Regel beschrieben wird:
\begin{gather*}
\frac{T \Rightarrow_{internCont}T' \vee T \Rightarrow_{container} T' \vee T \Rightarrow_{content} T'}{T \Rightarrow_{internStruct}T'}
\end{gather*}
\subsubsection{StructuralTypeMatcher} 
Der \emph{StructuralTypeMatcher} matcht einen \emph{required Typ} $R$ auf einen \emph{provided Typ} $P$ auf der Basis der Methoden-Signaturen, die in den Typen deklariert sind.
\\\\
Somit soll bspw. der Typ $\texttt{MedicalFireFighter}$ auf den Typ $\texttt{FireFighter}$ (siehe Listing \ref{lst:libEx}) gematcht werden. Als ein weiteres Beispiel, bezogen auf die Typen aus Listing 1, kann das Matching des Typs $\texttt{MedicalFireFighter}$ auf den Typ $\texttt{Doctor}$ angebracht werden.
\\\\
Damit ein required Typ $R$ auf einen provided Typ $P$ über den \emph{StrukturalTypeMatcher} gematcht werden kann, muss mindestens eine Methode aus $R$ zu einer Methode aus $P$ gematcht werden. Wie in \cite{moormann} soll die Reihenfolge, in der die Parameter in der jeweiligen Methode deklariert sind, keine Rolle spielen. Von daher wird das Matching der Parameter zweier Methoden $m$ und $m'$ wie folgt beschrieben:
\begin{gather*}
\mathit{matchingParams(m, m')} :=
\left\{
\begin{array}{l|l}
	&
	\{\mathit{P_1,...,P_n}\} = \mathit{params(m)} \wedge \mathit{ }
	\\
	\{\mathit{mP_1,...,mP_n}\}
	&
	\forall i \in \{1,...,n\}: \mathit{mP_i} \in \mathit{params(m'}) \wedge \mathit{ }
	\\
	&
	\mathit{mP_i} \Rightarrow_{internStruct} \mathit{P_i}
\end{array}
\right\}
\end{gather*}
\noindent
Das Matching zweier Methoden $m$ und $m'$ wird durch die Relation $\Rightarrow_{method}$ über folgende Regel beschrieben:
\begin{gather*}
\frac{\mathit{ret(m)} \Rightarrow_{internStruct} \mathit{ret(m')} \wedge \mathit{matchingParams(m,m')}}{m \Rightarrow_{method} m'}
\end{gather*}
\noindent
Die Menge der gematchten Methoden aus $R$ in $P$ wird darauf aufbauend durch folgende Funktion beschrieben:
\begin{gather*}
structM(R,P) := \left\{ 
				\begin{array}{l|l}
m	& \mathit{m} \in \mathit{methoden(R)} \wedge \mathit{ }
\\
	& \exists \mathit{m'} \in \mathit{methoden(P)} : m \Rightarrow_{method} m'
				\end{array}
              \right\}
\end{gather*}
\noindent
Die Matchingrelation für den \emph{StructuralTypeMatcher} wird durch folgende Regel beschrieben:
\begin{gather*}
\frac{structM(R,P) \neq \emptyset}{R \Rightarrow_{struct}P}
\end{gather*}


\subsection{Ergebnis der strukturellen Evaluation}\label{sec_ergStructEval}
Die gesamte Exploration wird für einen required Typ durchgeführt. Bei der strukturellen Evaluation sollen dabei Mengen von provided Typen ermittelt werden, deren Methoden in Kombination zu jeder Methode des required Typ ein Matching aufweisen. Die Mengen von provided Typen innerhalb einer Bibliothek $L$ für die dies in Bezug auf ein required Typ $R$ zutrifft, wird über die Funktion $cover$ beschrieben.

\begin{gather*}
cover(R,L) := 
\left\{\begin{array}{l|l}
					& T_1 \in L \wedge \text{...} \wedge T_n \in L 								\wedge \mathit{ }\\
\{T_1,...,T_n\}		& \mathit{methoden(R)} = \mathit{structM(R,T_1)}							\cup \mathit{ }\\
					& \texttt{...} \cup \mathit{structM(R, T_n)} 								\wedge \mathit{ }\\
					& \forall T \in \{T_1,...,T_n\}:											\mathit{structM(R,T)} \neq \emptyset
\end{array}\right\}
\end{gather*}

\begin{example}{bsp_cover}
Sei folgende Bibliothek $L$ gegeben.
\begin{lstlisting}[style = dsl]
provided Come extends Object{
	String hello()
	String goodMorning()
}

provided Leave extends Object{
	String bye()
}

required Greeting{
	String hello()
	String bye()
}
\end{lstlisting}
Über die Funktion $\mathit{cover}$ werden folgenden Mengen von Target-Typen für die Bildung von Proxies für den required Typ $\texttt{Greeting}$ ermittelt.
\begin{gather*}
\mathit{cover(\texttt{Greeting},L)} = \{
	\{\texttt{Come}\},\{\texttt{Leave}, \texttt{Come}\}
\}
\end{gather*}
\end{example}


\chapter{Forschungsziel und Abgrenzung}\label{chap_problem}
\section{Testgetriebene Codesuche}\label{sec_tdcs}
Die Idee der \emph{TDCS} beruht im Grunde auf dem Ziel der Wiederverwendung von Software, welches 1992 von Krueger wie folgt beschrieben wurde:
\emph{\glqq Software reuse is the process of creating software systems from existing software rather than building software systems from scratch.\grqq{}} \cite{krueger} In der \emph{TDCS} soll dieses Ziel in Verbindung mit dem Prozess der testgetriebenen Software-Entwicklung (testdriven development - \emph{TDD}) erreicht werden. \cite{hummel08} 
\\\\
Bei der \emph{TDCS} werden die jeweiligen Anforderungen an den zu suchenden Source Code durch die Entwickler*innen spezifiziert. Diese werden im Abschluss verwendet, um den relevanten Source Code aus einem Repository zu ermittelt. Darauf aufbauend kann das jeweilige Tool den Entwickler*innen Vorschläge für die Wiederverwendung des bestehenden Codes unterbreiten.
\\\\
Der Prozess der \emph{TDCS} wurde von Hummel und Janjic grundlegend als Zyklus beschrieben und wie in \abbref{tdr_cycle} dargestellt  \cite{Hummel2013}.
\myScalableFigure[0.6\linewidth]{tdr_cycle}{The testdriven reuse "cycle"  \cite{Hummel2013}}{tdr_cycle}
\noindent
Hier spezifizieren die Entwickler*innen eine Menge von Testfällen (a) aus denen von eine Search \Gls{Engine} (in der Abbildung \glqq Reuse System\grqq{} genannt) ein \Gls{Interface} extrahiert wird (b). Dieses \Gls{Interface} wird für die Suche nach Kandidaten, die zu diesem \Gls{Interface} passen, verwendet (c). Diese Kandidaten werden im Anschluss kompiliert, wobei mitunter eine Anpassung (Adaption) erfolgen muss, um das extrahierte \Gls{Interface} vollständig\footnote{ein (angepasster) Kandidat erfüllt ein \Gls{Interface} vollständig, wenn er zu jeder Methode des \Gls{Interface}s eine passende Methode anbietet.} zu erfüllen (d). Die letzte Aufgabe der Search \Gls{Engine} besteht dann im Test der kompilierten und mitunter adaptierten Kandidaten. Hierfür werden die von den Entwickler*innen in Schritt a spezifizierten Testfälle verwendet. Darauf aufbauend wird eine Liste von relevanten Kandidaten erarbeitet, aus der die Entwickler*innen eine Kandidaten zur weiteren Verwendung auswählen können (f).
\\\\
Zu beachten ist, dass die Entwickler*innen bei diesem Ansatz die zu verwendende Komponente letztendlich selbst auswählen müssen. Der Ansatz eignet sich also nicht zum Einsatz während der Laufzeit des Systems. Weiterhin ist zu erwähnen, dass das \Gls{Interface}, welches für die Suche verwendet wird, aus den von den Entwickler*innen spezifizierten Testfällen extrahiert wird. Im Rahmen dieser Arbeit soll das \Gls{Interface} jedoch vorgegeben werden\footnote{Die Vorgabe erfolgt durch die Entwickler*innen.}, da so der Explorationsalgorithmus und die beschriebenen Heuristiken besser nachvollzogen werden können.
\\\\
Der Ansatz zur \emph{TDCS} wurde bereits in \cite{sourcerer} von Bajaracharya et al.  verfolgt. Diese Gruppe entwickelte eine Search \Gls{Engine} namens \emph{Sourcerer}, welche die Suche von Open Source Code im Internet ermöglichte. Darauf aufbauend wurde von derselben Gruppe in \cite{Lemos} ein Tool namens \emph{CodeGenie} entwickelt, welches Softwareentwickler*innen die Code Suche über ein Eclipse-Plugin ermöglicht. In diesem Zusammenhang wurde erstmals der Begriff der \emph{TDCS} etabliert. Parallel dazu wurde in Verbindung mit der Dissertation Oliver Hummels \cite{hummel08} ebenfalls eine Weiterentwicklung von \emph{Sourcerer} veröffentlicht, welche unter dem Namen \emph{Merobase} bekannt ist und ebenfalls das Konzept der \emph{TDCS} verfolgt.
\\\\
In \cite{hummel08} wurden in Bezug auf die \emph{TDCS} drei weitere Voraussetzungen identifiziert, die in dem oben beschriebenen Zyklus nicht eindeutig erwähnt wurden:
\begin{enumerate}
\item Ein Software-Repository, in dem die wiederverwendbaren Softwareteile enthalten sind.
\item Ein Format für die Repräsentation dieser Softwareteile.
\item Ein Mechanismus, welcher in der Lage ist, das Repository zu durchsuchen.
\end{enumerate}
\noindent
In früheren Arbeiten wurden im Internet bestehende Code-Repositiories als Software-Repository verwendet. Die Repräsentation konnte dabei je nach Repository unterschiedliche Formen haben. Damit ist die Darstellung gemeint, auf deren Basis die Kandidaten aus dem Repository ermittelt werden. Daher muss es möglich sein sowohl die Kandidaten als auch das \Gls{Interface}, welches von den Entwickler*innen spezifiziert oder aus den Testfällen extrahiert wurde, in dieser Form zu beschreiben. Die Mechanismen, die in bestehenden Arbeiten für die Suche verwendet wurden, sind ebenfalls vielfältig. Eine Auflistung der am häufigsten verwendeten Ansätze und eine kurze Erklärung ist in \cite{Hummel2013} und \cite{hummel08} zu finden.
\\\\
In den derzeit jüngsten Arbeiten zu diesem Thema wurde versucht, den \emph{TDCS}-Ansatz immer tiefer in den Entwicklungsprozess zu verankern (vgl. \cite{kessel2018}). Darüber hinaus wurde versucht, die Komponenten, die den Entwickler*innen für die Wiederverwendung angeboten wurden, nach unterschiedlichen Kriterien zu sortieren. Dabei ist eine Vielzahl von Ranking Ansätzen entstanden, in denen die Abdeckung der funktionellen Anforderungen (bspw. in \cite{STOLEE201635}, \cite{kessel2015}), oder die Abdeckung der nicht-funktionelle Anforderungen (bspw. in \cite{kessel2016}) bestimmt und für die Sortierung verwendet wird. Zu bemerken ist jedoch, dass das Ranking  einen nachgelagerten Prozess darstellt\footnote{In Bezug auf \abbref{tdr_cycle} würde das Ranking zwischen Schritt e und f eingeordnet werden.}. Somit wird die Suche/Exploration der Search \Gls{Engine} durch ein solches Ranking nicht beschleunigt.

\section{Testgetriebene Exploration von EJBs}\label{sec_tdcs_ejb}
Diese Arbeit legt den Fokus auf die Exploration von \emph{Enterprise-Java-Beans} (\emph{EJBs}). Hummel identifizierte \emph{EJBs} bereits in \cite{hummel08} als eine Client-Server-Architektur für Software-Systeme, welche die Kommunikation zwischen Komponenten (so genannten \emph{Beans}), die auf physikalisch unterschiedlichen Maschinen laufen, koordinieren bzw. unterstützen können (vgl. auch \cite{ejbspec}). Dazu wird das jeweilige Software-System auf einem Applikationsserver deployed, der die EJB-Spezifikation \cite{ejbspec} erfüllt.
\\\\
Bei einer \emph{Bean} handelt es sich grundlegend um eine Java-Klasse, deren Struktur außerhalb dieser Klasse spezifiziert wurde. Seit der Version 3.0 der EJB-Spezifikation kann die Struktur durch ein Java-Interface spezifiziert werden. In früheren Versionen erfolgt dies in einer XML-Datei. \cite{ejbspec}
\\\\
Die \emph{Beans} können über einen \emph{EJB-Container} abgerufen werden. Zu diesem Zweck publiziert der \emph{EJB-Container} die \Gls{Interface}s der deployten \emph{Beans}, sodass diese auf den Clients über \Gls{JNDI} oder \Gls{DependencyInjection} zur Verfügung stehen \cite{ejbspec}.
\\\\
Bezogen auf die in \cite{hummel08} beschriebenen Voraussetzungen für die \emph{TDCS} wird der \emph{EJB-Container} in dieser Arbeit als Software-Repository angesehen. Die einzelnen Softwareteile werden in Form von Java-Interfaces repräsentiert. Und der Mechanismus zum Durchsuchen des Repositories wird durch die Publikation der Java-Interfaces der \emph{EJBs} durch den \emph{EJB-Container} bereitgestellt.
\\\\
Der Prozess für die Exploration von \emph{EJBs} unterscheidet sich leicht von dem aus \abbref{tdr_cycle}. Während in der Beschreibung von Hummer das \Gls{Interface} aus den Testfällen extrahiert wird, müssen die Entwickler*innen hier das \Gls{Interface} selbst entwerfen. Dies erfolgt in der Form eines Java-Interfaces. Die Tests werden als Java-Klassen deklariert, die über ihre Methoden eine Validierung der \emph{EJBs} erlauben.
\\\\
Darüber hinaus muss klargestellt werden, dass die Exploration der \emph{EJBs} zur Laufzeit durchgeführt wird, da anderenfalls der \emph{EJB-Containe}r nicht zur Verfügung steht. Somit muss die Exploration während der Laufzeit gestartet werden können. Zu diesem Zweck wird eine \emph{Explorationskomponente} in das System integriert. 
\\\\
Der Prozess für den beschriebenen Ansatz kann somit in einen Implementierungsprozess und einen Explorationsprozess, welcher zur Laufzeit durchgeführt wird, eingeteilt werden.
\\\\
In \abbref{ejb_expl_impl} ist der Implementierungsprozess aufgezeigt:
\myScalableFigure[1.0\linewidth]{ejb_expl_impl}{Implementierungsprozess}{ejb_expl_impl}
\noindent
Wie bereits erwähnt, deklarieren die Entwickler*innen das \Gls{Interface} (1) und die Testklassen (2). Im dritten Schritt erfolgt der Aufruf der Explorationskomponente, wodurch zur Laufzeit der Explorationsprozess (siehe \abbref{ejb_expl_search}) gestartet wird. Das Ergebnis des Explorationsprozesses kann in Form des deklarierten \Gls{Interface}s weiter verwendet werden. Allerdings muss der Entwickler auch davon ausgehen, dass durch die Explorationskomponente keine passende Komponente ermittelt werden konnte.
\\\\
Die folgende Abbildung stellt den Explorationsprozess dar:
\myScalableFigure[1.0\linewidth]{ejb_expl_search}{Explorationsprozess}{ejb_expl_search}
\noindent
Hier wird zuerst eine \emph{strukturelle Evaluation} auf Basis des vorgegebenen \Gls{Interface}s und der vom \emph{EJB-Container} publizierten \Gls{Interface}s durchgeführt. 
Dieser Schritt ist mit dem Suchen der Kanditaten aus \abbref{tdr_cycle} vergleichbar. Auf Basis der Kandidaten, die bei der \emph{sturkturellen Evaluation} ermittelt wurden, werden im zweiten Schritt \emph{Proxies} generiert, durch die die Methodenaufrufe auf dem vorgegebenen \Gls{Interface} an die jeweiligen Kandidaten delegiert werden. Dies ist mit Schritt d aus \abbref{tdr_cycle} zu vergleichen. Im nächsten Schritt (\emph{semantische Evaluation}) werden - analog zu Schritt e aus \abbref{tdr_cycle} - die vorgegebenen Testklassen verwendet, um eben jene \emph{Proxies} zu validieren. Sofern ein valider \emph{Proxy} gefunden wurden, wird dieser im 4. Schritt von der Explorationskomponente zurückgegeben.
\\\\
Wie in Kapitel \ref{chap_foundation} noch beschrieben wird, besteht die Möglichkeit, dass das vorgegebene \Gls{Interface} erst durch eine Kombination einiger \emph{EJBs} gänzlich erfüllt werden kann. Eine solche Kombination der \emph{Beans} soll über ein \emph{Proxy-Objekt} erreicht werden, welches bei der Exploration im Anschluss an die \emph{strukturelle Evaluation} generiert wird. Das \emph{Proxy-Objekt} muss dann zum einen in der Lage sein, die Methodenaufrufe wie in den Methoden-Signaturen den vorgegebenen \Gls{Interface}s entgegenzunehmen und diese dann zum anderen an die entsprechende \emph{Bean}, die eine dazu passende Methode bereitstellt, delegieren.
\\\\
Da die Exploration wie oben beschrieben zur Laufzeit durchgeführt wird, sollte die Suche abgebrochen werden, sofern ein \emph{Proxy} erfolgreich validiert wurde. Anderenfalls kann es bspw. zu unnötigen Timeouts laufender Transaktionen kommen. Um darüber hinaus ein schnelles Auffinden eines validen \emph{Proxies} zu gewährleisten, können bei der \emph{semantischen Evaluation} Heuristiken verwendet werden, welche die Generierung von \emph{Proxies} und deren Validierung beschleunigen. Die vorliegende Arbeit dient hauptsächlich der Evaluation solcher Heuristiken.

\chapter{Forschungsziel und Abgrenzung}
\section{Testgetriebene Codesuche}
Die Idee der testgetriebenen Codesuche (testdriven codesearch - TDCS) beruht im Grunde auf dem Ziel der Wiederverwendung von Software, welches 1992 von Krueger wie folgt beschrieben wurde:
\emph{\glqq Software resure is the process of creating software systems from existing software rather than building software systems from scratch.\grqq{}} \cite{krueger} In der TDCS soll dieses Ziel in Verbindung mit dem Prozess der testgetriebenen Software-Entwicklung (testdriven development - TDD) erreicht werden. \cite{hummel08} 
\\\\
TDCS beruht grundlegend darauf, dass der Entwickler Anforderungen spezifiziert, die im Anschluss verwendet werden, um relevanten Source Code aus einem Repository hinsichtlich dieser Anforderungen zu ermittelt. Darauf aufbauend kann das jeweilige Tool dem Entwickler Vorschläge für die Wiederverwendung bestehenden Codes unterbreiten.
\\\\
Der Prozess der TDCS wurde von Hummel und Janjic grundlegend wie in Abbildung \abbref{tdr_cycle} dargestellt werden \cite{Hummel2013}.
\myScalableFigure[0.6\linewidth]{tdr_cycle}{The testdriven reuse "cycle"  \cite{Hummel2013}}{tdr_cycle}
\noindent
Hier spezifiziert der Entwickler eine Menge von Testfällen (a) aus denen von einem Suchtool (in der Abbildung \glqq Reuse System\grqq{} genannt) ein Interface extrahiert wird (b). Dieses Interface wird für die Suche nach Kandidaten, die dieses Interface erfüllen, verwendet (c). Diese Kandidaten werden im Anschluss kompiliert, wobei mitunter eine Anpassung (Adaption) erfolgen muss, um das extrahierte Interface in Gänze zu erfüllen (d). Die letzte Aufgabe des Suchtools besteht dann im Test der kompilierten und mitunter adaptierten Kandidaten. Hierfür werden die vom Entwickler in Schritt a spezifizierten Testfälle verwendet. Darauf aufbauend wird eine Liste von relevanten Komponenten erarbeitet, aus der der Entwickler eine zur weiteren Verwendung auswählen kann (f).
\\\\
Zu beachten ist, dass der Entwickler bei diesem Ansatz die zu verwendende Komponente letztendlich selbst auswählen muss. Weiterhin ist zu erwähnen, dass das Interface, welches für die Suche verwendet wird, aus den vom Entwickler spezifizierten Testfällen extrahiert wird. Im Rahmen dieser Arbeit wird das Interface jedoch vorgegeben, da so der Explorationsalgorithmus und die beschriebenen Heuristiken besser nachvollzogen werden können.
\\\\
Der Ansatz zur TDCS wurde bereits in \cite{sourcerer} von Bajaracharya et al.  verfolgt. Diese Gruppe entwickelte eine Search Engine namens Sourcerer, welche Suche von Open Source Code im Internet ermöglichte. Darauf aufbauend wurde von derselben Gruppe in \cite{Lemos} ein Tool namens CodeGenie entwickelt, welches einem Softwareentwickler die Code Suche über ein Eclipse-Plugin ermöglicht. In diesem Zusammenhang wurde erstmals der Begriff der Test-Driven Code Search etabliert. Parallel dazu wurde in Verbindung mit der Dissertation Oliver Hummels \cite{hummel08} ebenfalls eine Weiterentwicklung von Sourcerer veröffentlicht, welche unter dem Namen Merobase bekannt ist und ebenfalls das Konzept der TDCS verfolgt.
\\\\
In \cite{hummel08} wurden in Bezug auf die TDCS drei weitere Voraussetzungen identifiziert, die in dem oben beschriebenen Zyklus nicht eindeutig erwähnt wurden :
\begin{enumerate}
\item Ein Software-Repository, in dem die wiederverwendbaren Softwareteile enthalten sind.
\item Ein Format für die Repräsentation dieser Softwareteile.
\item Ein Mechanismus, welcher in der Lage ist, das Repository zu durchsuchen.
\end{enumerate}
\noindent
Als Software-Repository wurden in den früheren Arbeiten im Internet bestehende Code-Repositiories verwendet. Die Repräsentation konnte dabei je nach Repository unterschiedliche Formen haben. Dabei geht es um die Darstellung auf deren Basis die Kandidaten aus dem Repository ermittelt werden. Somit müssen sowohl die Kandidaten als auch das Interface, welches vom Entwickler spezifiziert oder aus den Testfällen extrahiert wurde, in dieser Form repräsentiert werden können. Die Mechanismen, die für die Suche verwendet wurden, waren ebenfalls vielfältig. Eine auflistung der am häufigsten verwendeten Ansätze und eine kurze Erklärung ist in \cite{Hummel2013} und \cite{hummel08} zu finden.
\\\\
In den jüngsten Arbeiten zu diesem Thema wird versucht, den TDCS-Ansatz immer tiefer in den Entwicklungsprozess zu verankern (vgl. \cite{kessel2018}). Darüber hinaus wurde versucht, die Komponenten, die dem Entwickler für die Wiederverwendung angeboten wurden, nach unterschiedlichen Kriterien zu sortieren. Dabei ist eine Vielzahl von Ranking Ansätzen entstanden, in denen die Abdeckung der funktionellen Anforderungen (bspw. in \cite{STOLEE201635}, \cite{kessel2015}), oder sogar die Abdeckung der nicht-funktionelle Anforderungen (bspw. in \cite{kessel2016}) für die Sortierung zu nutzen. Zu bemerken ist jedoch, dass ein Ranking in Bezug auf die Exploration an sich einen nachgelagerten Prozess darstellt. Um die Exploration selbst zu beschleunigen, bedarf es also Verfahren, die während der Exploration zur Anwendung kommen.

\section{Testgetriebene Exploration von EJBs}\label{sec_tdcs_ejb}
Diese Arbeit legt den Fokus auf die Suche von Enterprise-Java-Beans (EJBs). Hummel identifizierte EJBs bereits in \cite{hummel08} als eine Client-Server-Architektur für Software-Systeme, welche die Kommunikation zwischen Komponenten (so genannte \emph{Beans}), die auf physikalisch unterschiedlichen Maschinen laufen, koordinieren bzw. unterstützen können (vgl. auch \cite{ejbspec}). Dazu wird das jeweilige Software-System auf einem Applikationsserver deployed, der die EJB-Spezifikation \cite{ejbspec} erfüllt.
\\\\
Bei einer Bean handelt es sich grundlegend um eine Java-Klasse, deren Struktur außerhalb dieser Klasse spezifiziert wurde.Seit der Version 3 kann die Struktur durch ein Java-Interface spezifiziert werden. In früheren Versionen erfolgt dies in einer XML-Datei. \cite{ejbspec}
\\\\
Die Beans können über einen \emph{EJB-Container} abgerufen werden. Zu diesem Zweck publiziert der EJB-Container die Interfaces der deployten Beans, sodass diese auf den Clients über \emph{JNDI} oder \emph{Dependency Injection} zur Verfügung stehen \cite{ejbspec}.
\\\\
Bezogen auf die in \cite{hummel08} beschriebenen Voraussetzungen für die TDCS wird der EJB-Container in dieser Arbeit als Software-Repository angesehen. Die einzelnen Softwareteile (EJBs) werden in Form von Java-Interfaces repräsentiert. Und der Mechanismus zum Durchsuchen des Repositories wird durch die Publikation der Java-Interfaces der EJBs durch den EJB-Container bereitgestellt.
\\\\
Der Prozess für die Exploration von EJBs unterscheidet sich leicht von dem aus \abbref{tdr_cycle}. Während in der Beschreibung von Hummer das Interface aus den Testfällen extrahiert wird, muss der Entwickler hier der das Interface selbst entworfen werden. Dies erfolgt in der Form eines Java-Interfaces. Als Tests werden Java-Klassen verwendet werden, die über ihre Methoden eine Validierung der EJBs erlauben.
\\\\
Darüber hinaus muss klargestellt werden, dass die Exploration der EJBs zur Laufzeit durchgeführt wird, da anderenfalls der EJB-Container nicht zur Verfügung steht. Somit muss die Exploration während der Laufzeit gestartet werden können. Zu diesem Zweck wird eine Explorationskomponente in dem System integriert. 
\\\\
Der Prozess für den beschriebenen Ansatz kann dann in einen Implementierungsprozess und einen Explorationsprozess, welcher zur Laufzeit durchgeführt wird, geteilt werden.
\\\\
In \abbref{ejb_expl_impl} ist der Implementierungsprozess aufgezeigt.
\myScalableFigure[0.6\linewidth]{ejb_expl_impl}{Implementierungsprozess}{ejb_expl_impl}
\noindent
Wie bereits erwähnt, deklariert der Entwickler das Interface (1) und die Testklassen (2). Im dritten Schritt erfolgt der Aufruf der Explorationskomponente, wodurch zur Laufzeit der Explorationsprozess (siehe \abbref{ejb_expl_search}) gestartet wird. Das Ergebnis des Explorationsprozesses kann dann im Form des deklarierten Interfaces weiterverwendet werden. Allerdings muss der Entwickler auch davon ausgehen, dass durch die Explorationskomponente kein Ergebnis in Form eines validen Proxies ermittelt wird.
\\\\
Die folgende Abbildung stellt den Explorationsprozess dar:
\myScalableFigure[0.6\linewidth]{ejb_expl_search}{Explorationsprozess}{ejb_expl_search}
\noindent
Hier wird zuerst eine \emph{strukturelle Evaluation} auf Basis des vorgegebenen Interfaces und der vom EJB-Container publizierten Bean-Interfaces durchgeführt. 
Dieser Schritt ist mit dem Suchen der Kanditaten aus \abbref{tdr_cycle} vergleichbar. Auf Basis der Kandidaten, die bei der sturkturellen Evaluation ermittelt wurden, werden im zweiten Schritt Proxies generiert, durch die die Methodenaufrufe auf dem vorgegebenen Interface an die jeweiligen Kandidaten delegiert werden. Im nächsten Schritt (\emph{semantische Evaluation}) werden die vorgegeben Testklassen verwendet, um eben jene Proxies zu validieren. Sofern ein valider Proxy gefunden wurden, wird dieser im 4. Schritt von der Explorationskomponente zurückgegeben.
\\\\
Da bei der Ermittlung der Beans lediglich die Methoden-Signaturen eine Rolle spielen, besteht die Möglichkeit, dass die Methoden einer einzelnen Bean nur zu einem Teil der Methoden des vorgegebenen Interfaces passen. In diesem Fall kann der Ansatz dazu verwendet werden, für die übrigen Methoden eine andere Bean zu finden, die dafür passende Methoden bereitstellt. Damit müssten die beiden Beans jedoch miteinander kombiniert werden, um das vorgegebene Interface in Gänze zu matchen.
\\\\
Dieses Problem soll in dieser Arbeit ebenfalls adressiert werden. Die Kombination der Beans soll über ein Proxy-Objekt erreicht werden, welches bei der Exploration im Anschluss an die Strukturelle Evaluation generiert wird. Das Proxy-Objekt muss dann zum einen in der Lage sein, die Methodenaufrufe wie in den Methoden-Signaturen den vorgegebenen Interfaces entgegenzunehmen und diese dann zum Anderen an die entsprechende Bean, die eine dazu passende Methode bereitstellt, delegieren.
\\\\
Da die Exploration wie oben beschrieben zur Laufzeit durchgeführt wird, sollte die Suche abgebrochen werden, sofern ein generierter Proxy erfolgreich validiert wurde. Anderenfalls kann es bspw. zu unnötigen Timeouts laufender Transaktionen kommen. Um darüber hinaus ein schnelles Auffinden eines validierten Proxies zu gewährleisten, können bei der semantischen werden in diesem letzten Schritt Heuristiken verwendet, welche die Generierung von Proxies und der positiven Validierung eines dieser Proxies beschleunigen. Die vorliegende Arbeit dient hauptsächlich der Evaluation solcher Heuristiken.

\chapter{Einleitung}
\section{Motivation}
In größeren Software-Systemen ist es üblich, dass mehrere Komponenten miteinander über Schnittstellen kommunizieren. In der Regel werden diese Schnittstellen so konzipiert, dass sie Informationen oder Services anbieten, die von anderen Komponenten abgefragt und benutzt werden können. Dabei wird zwischen der Komponente, welche die Schnittstelle implementiert - als angebotene Komponente - und der Komponente, welche die Schnittstelle nutzen soll - als nachfragende Komponente - unterschieden (siehe \abbref{motiv}). 
\myScalableFigure[0.6\linewidth]{motiv}{Abhängigkeiten von nachfragenden und angebotenen Komponenten}{motiv}
\noindent
Wird von einer nachfragenden Komponente eine Information benötigt, die in dieser Form noch nicht angeboten wird, so wird häufig ein neues Interface für diese benötigte Information erstellt, welches dann passend dazu implementiert wird. Dabei muss neben der Anpassung der nachfragenden Komponente auch eine Anpassung oder Erzeugung der anbietenden Komponente erfolgen und zusätzlich das neue Interface deklariert werden. Zudem bedingt eine nachträgliche Änderung der neuen Schnittstelle ebenfalls eine Anpassung der drei genannten Artefakte.\\\\
In einem großen Software-System mit einer Vielzahl von bestehenden Schnittstellen ist eine gewisse Wahrscheinlichkeit gegeben, dass die Informationen oder Services, die von einer neuen nachfragenden Komponente benötigt werden, in einer ähnlichen Form bereits existieren. Das Problem ist jedoch, dass die manuelle Evaluation der Schnittstellen mitunter sehr aufwendig bis, aufgrund von unzureichender Dokumentation und Kenntnis über die bestehenden Schnittstellen, unmöglich ist.
\\\\
Weiterhin ist es denkbar, dass ein Software-System auf unterschiedlichen Maschinen verteilt wurde und dadurch Teile des Systems ausfallen können. Das hat zur Folge, dass die Implementierung bestimmter Schnittstellen nicht erreichbar ist. Dadurch, dass eine Schnittstelle durch eine nachfragende Komponente explizit referenziert wird, kann eine solche Komponente nicht korrekt arbeiten, wenn die Implementierung der Schnittstelle nicht erreichbar ist, obwohl die benötigten Informationen und Services vielleicht durch andere Schnittstellen, deren Implementierung durchaus zur Verfügung stehen, bereitgestellt werden könnten.
\\\\
Dies führt zu der Überlegung, ob eine nachfragende Komponente anstelle der Referenzierung einer Schnittstelle eine Spezifizierung der Schnittstelle vornimmt, anhand derer eine angebotene Komponente, die dieses Spezifikation erfüllt, gefunden werden kann.
\\\\
Ein solches Vorgehen wird bei der testgetriebene Codesuche (testdriven codesearch - \emph{TDCS}) verfolgt, welche als Basis für diese Arbeit herangezogen wird. Dabei stellt der Entwickler eine Menge von Suchparametern zusammen, die er an eine so genannte Source Engine übergibt. Die Suchparameter sind dabei jedoch stark an dem orientiert, was der Entwickler benötigt und weniger daran, was tatsächlich im Repository vorliegt. Diese Source Engine durchsucht anschließend ein Repository nach Komponenten (im weitesten Sinne), die zu den gestellten Suchparametern passen. 
\\\\
Die Suchergebnisse werden aufgelistet und der Entwickler entscheidet letztendlich explizit, welche Komponente verwenden möchte. Die Verwendung der Komponente läuft dann jedoch auf eine Referenzierung dieser in der nachfragenden Komponente hinaus. Somit arbeiten die Source Engines also nicht zur Laufzeit des Systems, in dem die Komponenten verwendet werden sollen.
\\\\
In dieser Arbeit soll eine solche Exploration jedoch zur Laufzeit erfolgen, sodass eine explizite Referenzierung der angebotenen Komponente nicht erfolgen muss. Dabei ist die Zeit als Ressource während der Suche nach einer passenden Komponente als knapp anzusehen. Aus diesem Grund werden in dieser Arbeit Heuristiken vorgeschlagen, die ein gezieltes Auffinden einer passenden Komponente ermöglichen und damit die Suche beschleunigen.

\section{Aufbau dieser Arbeit}
Zuerst wird in Kapitel \ref{chap_problem} auf den aktuellen Forschungsstand zur \emph{TDCS} eingegangen. Im Anschluss daran wird beschrieben, wie sich die \emph{TDCS} auf einen Ansatz, in dem zur Laufzeit nach Komponenten gesucht wird, eingegangen, um so eine Abgrenzung zu den früheren Arbeiten zu schaffen.
\\\\
In Kapitel \ref{chap_foundation} werden die einzelnen Schnritte, die während der Exploration durchgeführt werden, sowie die zu evaluierenden Heuristiken formal beschrieben.
% Dies teilt sich in vier Bereiche. Zuerst wird beschrieben, wie das Matching zwischen den angebotenen und den erwarteten Komponenten  hergestellt wird. Darauf aufbauend wird beschrieben, wie die matchenden angebotenen Komponenten miteinander kombiniert werden und somit neue Komponenten (so genannte Proxies) bilden. Im dritten Teil (Semantische Evaluation) wird das grundsätzliche Vorgehen bei der Applikation der Testfälle auf eben diese Proxies beschrieben. Und der letzte Teil beinhaltet die Beschreibung der Heuristiken und deren Integration in die semantische Evaluation.
\\\\
Kapitel \ref{chap_impl} gibt einen kurzen Überblick über die Implementierung der in Kapitel \ref{chap_foundation} genannten Aspekte.
\\\\
In Kapitel \ref{chap_evaluation} werden die Untersuchungsergebnisse, die unter Anwendung der Heuristiken im Einzelnen und in Kombination zusammengetragen wurden, vorgestellt. 
\\\\
Die Auswertung dieser Ergebnisse erfolgt in Kapitel \ref{chap_disc} zusammen mit einer kritischen Betrachtung des in der Arbeit vorgestellten Ansatzes, sowie einer kurzen Betrachtung möglicher Erweiterungen für diesen Ansatz.
\\\\
Komplettiert wird die Arbeit durch eine kurzen Zusammenfassung der Ergebnisse und einem Ausblick in Kapitel \ref{chap_finish}.
%\input{object_of_investigation}
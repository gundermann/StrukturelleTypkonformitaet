\chapter{Einleitung}
\section{Motivation}
In größeren Software-Systemen ist es üblich, dass mehrere Komponenten miteinander über Schnittstellen kommunizieren. In der Regel werden diese Schnittstellen so konzipiert, dass sie Informationen oder Services anbieten, die von anderen Komponenten abgefragt und benutzt werden können. Dabei wird zwischen der Komponente, welche die Schnittstelle implementiert - als angebotene Komponente - und der Komponente, welche die Schnittstelle nutzen soll - als nachfragende Komponente - unterschieden (siehe \abbref{motiv}). 
\myScalableFigure[0.6\linewidth]{motiv}{Abhängigkeiten von nachfragenden und angebotenen Komponenten}{motiv}
\noindent
Wird von einer nachfragenden Komponente eine Information benötigt, die in dieser Form noch nicht angeboten wird, so wird häufig ein neues Interface für diese benötigte Information erstellt, welches dann passend dazu implementiert wird. Dabei muss neben der Anpassung der nachfragenden Komponente auch eine Anpassung oder Erzeugung der anbietenden Komponente erfolgen und zusätzlich das neue Interface deklariert werden. Zudem bedingt eine nachträgliche Änderung der neuen Schnittstelle ebenfalls eine Anpassung der drei genannten Artefakte.\\\\
In einem großen Software-System mit einer Vielzahl von bestehenden Schnittstellen ist eine gewisse Wahrscheinlichkeit gegeben, dass die Informationen oder Services, die von einer neuen nachfragenden Komponente benötigt werden, in einer ähnlichen Form bereits existieren. Das Problem ist jedoch, dass die manuelle Evaluation der Schnittstellen mitunter sehr aufwendig bis, aufgrund von unzureichender Dokumentation und Kenntnis über die bestehenden Schnittstellen, unmöglich ist.
\\\\
Weiterhin ist es denkbar, dass ein Software-System auf unterschiedlichen Maschinen verteilt wurde und dadurch Teile des Systems ausfallen können. Das hat zur Folge, dass die Implementierung bestimmter Schnittstellen nicht erreichbar ist. Dadurch, dass eine Schnittstelle durch eine nachfragende Komponente explizit referenziert wird, kann eine solche Komponente nicht korrekt arbeiten, wenn die Implementierung der Schnittstelle nicht erreichbar ist, obwohl die benötigten Informationen und Services vielleicht durch andere Schnittstellen, deren Implementierung durchaus zur Verfügung stehen, bereitgestellt werden könnten.
\\\\
Dies führt zu der Überlegung, ob es nicht möglich ist, dass eine nachfragende Komponente einfach selbst spezifizieren kann, welche Informationen oder Services sie erwartet, wodurch auf der Basis dieser Spezifikation eine passende anbietende Komponente gefunden werden kann.
\\\\
Ein solches Verfahren beschreibt die testgetriebene Codesuche, welche als Basis für diese Arbeit herangezogen wird. Dabei durchsucht eine so genannte Sourch Engine ein Repository nach Komponenten (im weitesten Sinne), die zu den gestellten Suchparametern passen. Die Suchparameter sind dabei jedoch stark an dem orientiert, was der Entwickler benötigt und weniger daran, was tatsächlich im Repository vorliegt.
\\\\
Diese Source Engines arbeiten in der Regel nicht zur Laufzeit des Systems. Welche der gefundenen Komponenten letztendlich im System zur Anwendung kommen, entscheidet der jeweilige Entwickler explizit. Dem entgegen richtet sich der Ansatz, welcher in dieser Arbeit vorgestellt wird, an der Suche zur Laufzeit aus. Von daher ist es notwendig, die Exploration möglichst schnell und zielgerichtet durchzuführen.
\\\\
Aus diesem Grund werden in dieser Arbeit Heuristiken vorgeschlagen, die ein gezieltes Auffinden einer zu den Suchparametern passenden Komponente ermöglichen und damit die Suche beschleunigen.

\section{Aufbau dieser Arbeit}
Zuerst wird in dieser Arbeit auf den Ansatz der testgetriebenen Codesuche eingegangen. Im Anschluss daran wird beschrieben, wie dieser Ansatz mit einem EJB-Container als Repository bezogen werden kann und welche Anforderungen sich aufgrund der Tatsache, dass die Exploration zur Laufzeit durchgeführt wird, ergeben. Dazu wird das System, in dem die Evaluierung der Heuristiken vorgenommen wurde kurz vorgestellt.
\\\\
In Kapitel \ref{chap_foundation} werden die Exploration und die Heuristiken formal beschrieben. Dies teilt sich in vier Bereiche. Zuerst wird beschrieben, wie das Matching zwischen den angebotenen und den erwarteten Komponenten  hergestellt wird. Darauf aufbauend wird beschrieben, wie die matchenden angebotenen Komponenten miteinander kombiniert werden und somit neue Komponenten (so genannte Proxies) bilden. Im dritten Teil (Semantische Evaluation) wird das grundsätzliche Vorgehen bei der Applikation der Testfälle auf eben diese Proxies beschrieben. Und der letzte Teil beinhaltet die Beschreibung der Heuristiken und deren Integration in die semantische Evaluation.
\\\\
Kapitel \ref{chap_impl} gibt einen kurzen Überblick über die Implementierung der in Kapitel \ref{chap_foundation} genannten Aspekte.
\\\\
In Kapitel \ref{chap_evaluation} werden die Untersuchungsergebnisse, die unter Anwendung der Heuristiken im Einzelnen und in Kombination zusammengetragen wurden, vorgestellt. 
\\\\
Die Auswertung dieser Ergebnisse erfolgt in Kapitel \ref{chap_disc} zusammen mit einer kritischen Betrachtung des in der Arbeit vorgestellten Ansatzes zur testgetriebenen Exploration von EJBs während der Laufzeit, sowie einer kurzen Betrachtung möglicher Erweiterungen für diesen Ansatz.
\\\\
Komplettiert wird die Arbeit mit einer kurzen Zusammenfassung der Ergebnisse und einem Ausblick in Kapitel \ref{chap_finish}.
%\input{object_of_investigation}
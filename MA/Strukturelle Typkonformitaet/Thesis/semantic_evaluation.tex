\section{Semantische Evaluation}\label{sec_semEval}
Das Ziel der semantischen Evaluation ist es, einen der Proxies, die aus den Mengen von Target-Typen, die im Rahmen der strukturellen Evaluation erzeugt werden können, hinsichtlich der vordefinierten Testfälle zu evaluieren. Da die gesamte Exploration zur Laufzeit des Programms durchgeführt wird, stellt sie hinsichtlich der nicht-funktionalen Anforderungen eine zeitkritische Komponente dar.
\\\\
Da die Anforderungen an die gesuchte Komponente mit bedacht spezifiziert werden müssen, ist es irrelevant, ob es mehrere Proxies gibt, die hinsichtlich der vordefinierten Testfällen positiv evaluatiert werden können. Es ist ausreichend lediglich ein Proxy zu finden, dessen Semantik zu positiven Ergebnissen hinsichtlich aller vordefinierten Testfälle führt.
\subsection{Besonderheiten der Testfälle}\label{sec_testanforderungen}
Bei den vordefinierten Tests handelt es sich auf formaler Ebene um Typen, die eine eval-Methode mit der Struktur $\texttt{boolean eval( proxy )}$ anbieten, welche einen Proxy als Parameter erwartet und ein Objekt vom Typ $\texttt{boolean}$ zurückgibt. Weiterhin verfügt ein Test über ein Attribut $\texttt{triedMethodCalls}$, in dem eine Liste von Methodennamen des Proxies, die bei der Durchführung der eval-Methode aufgerufen wurden, hinterlegt ist.
\\\\
Die Implementierung der eval-Methode ist an folgende Bedingungen geknüpft:
\begin{enumerate}
\item Vor dem Aufruf einer Methode auf dem als Parameter übergebenen Proxy-Objekt, wird der Name dieser Methode in der Liste im Feld $\texttt{triedMethodCalls}$ ergänzt.
%\item Nach einem fehlgeschlagenen Aufruf einer Methode auf dem als Parameter übergebenen Proxy-Objekt, wird das Feld $\texttt{failedMethod}$ mit dem Namen der fehlgeschlagenen Methode belegt. Zusätzlich wird die eval-Methode direkt danach mit dem Rückgabewert $\texttt{false}$ beendet.
\item Wenn der Proxy den Test erfüllt, wird der Wert $\texttt{true}$ zurückgegeben. Anderenfalls wird der Wert $\texttt{false}$ zurückgegeben.
\end{enumerate}

\begin{example}{xmpl_evalMethode}
In folgendem Listing \ref{lst_examEval} ist eine eval-Methode aufgeführt, die die oben genannten Bedingungen erfüllt. Es sei davon auszugehen, dass der als Parameter übergebene Proxy eine Methode mit der Struktur $\methodForm{Integer}{add}{Integer x, Integer y}$
anbietet. Der Fehlschlag ($\texttt{err}$) dieser Methode wird über einen Try-Catch-Block abgefangen.
\begin{lstlisting}[style = pseudo, label = lst_examEval, caption = Beispielhafte Implementierung einer eval-Methode, captionpos = b]
function eval( proxy ){
	res = 0	
	triedMethodCalls.add( "add" )
	res = proxy.add(1, 1)
	return res == 2;
}
\end{lstlisting}
\end{example}

\subsection{Algorithmus für die semantische Evaluation}\label{sec_semEvalAlgo}
Bei der Exploration soll letztendlich in einer Bibliothek $L$ zu einem vorgegebenen required Type $R$ ein Proxy gefunden werden. Die Mengen der Target-Typen auf deren Basis mehrere Proxies erzeugt werden können, wurden im Abschnitt \ref{sec_anzahlProxies} über $\mathit{cover(R,L)}$ beschrieben. Die in $T = \mathit{cover(R,L)}$ befindlichen Mengen können eine unterschiedliche Anzahl von Target-Typen enthalten. Die maximale Mächtigkeit einer Menge $T_i \in T$ ist gleich der Anzahl der Methoden in $R$.
\begin{gather*}
\mathit{maxTargets(R)} := |\mathit{methoden(R)}|
\end{gather*}
\noindent
In Bezug zur Funktion $\mathit{cover}$ gilt:
\begin{gather*}
\forall T \in \mathit{cover(R,L)} : |T| \leq \mathit{maxTargets(R)}
\end{gather*}
\noindent
\\
Das in dieser Arbeit beschriebene Konzept basiert auf der Annahme, dass der gesamte Anwendungsfall - oder Teile davon - , der mit der vordefinierten Struktur und den vordefinierten Tests abgebildet werden soll, schon einmal genauso oder so ähnlich in dem gesamten System implementiert wurde. Aus diesem Grund kann für die semantische Evaluation davon ausgegangen werden, dass die erfolgreiche Durchführung aller relevanten Tests umso wahrscheinlicher ist, je weniger Target-Typen im Proxy verwendet werden.
\\\\
Sei folgende Funktion für eine Menge von Target-Typen $T \in \mathit{cover(R,L)}$ und eine ganze Zahl $a > 0$ definiert:
\begin{gather*}
\mathit{targetSets(T,a)} := \{T_i | T_i \in T \wedge |T_i| = a\}
\end{gather*}
\noindent
Ausgehend von einer Bibliothek $L$ kann der Algorithmus für die semantische Evaluation der Proxies, die für einen \emph{required Typ} $R$ mit den Mengen der Target-Typen $T = \mathit{cover(R, L)}$ erzeugt werden können, und der Menge von Tests (Parameter $\texttt{tests}$) wie folgt im Pseudo-Code beschrieben werden. Die globale Variable $\texttt{passedTests}$ enthält dabei die Anzahl der für den aktuell zu überprüfenden Proxy erfolgreich durchgeführten Tests. Außerdem sei davon auszugehen, dass die Funktionen aus Abschnitt \ref{sec_proxyGen} wie beschrieben definiert sind.
\begin{lstlisting}[style = pseudo, caption = Semantische Evaluation ohne Heuristiken, captionpos = b, label = lst_semEval]
passedTests = 0

function semanticEval( R, T, tests ){
	for( anzahl = 1; anzahl <= $\mathit{maxTargets( R )}$; i++ ){
		for( targets : $\mathit{targetSets( T, anzahl )}$ ){
			relProxies = $\mathit{proxies( R, targets )}$
			proxy = evalProxies( relProxies, tests )	
			if( proxy != null ){
				// passenden Proxy gefunden
				return proxy
			}
		}
	}
	// kein passenden Proxy gefunden
	return null;
}

function evalProxies(proxies, tests){
	for( proxy : proxies ){
		passedTests = 0
		evalProxy(proxy, tests)
		if( passedTests == tests.size ){
			// passenden Proxy gefunden
			return proxy
		}
	}
	// kein passenden Proxy gefunden
	return null
}

function evalProxy(proxy, tests){
	for( test : tests ){
		if( !test.eval( proxy ) ){
			\\ wenn ein Test fehlschlaegt, dann entspricht der 
			\\ Proxy nicht den semantischen Anforderungen
			return
		}
		passedTests = passedTests + 1
	}
}
\end{lstlisting}
Die Dauer der Laufzeit der in Listing \ref{lst_semEval} definierten Funktionen hängt maßgeblich von der Anzahl der Proxies ab, die für den required Typ $R$ in der Bibliothek $L$ erzeugt werden können (siehe auch Abschnitt \ref{sec_anzahlProxies} Funktion $\mathit{proxyCount}$). Im schlimmsten Fall müssen alle Proxies hinsichtlich der vordefinierten Tests erzeugt und evaluiert werden. Um die Anzahl dieser Proxies zu reduzieren, werden die im folgenden Abschnitt beschriebenen Heuristiken verwendet.


\section{Heuristiken}\label{sec_heuristics}
Die Heuristiken werden an unterschiedlichen Stellen des Algorithmus aus Listing \ref{lst_semEval} eingebaut. Teilweise ist es für die Verwendung einer Heuristik notwendig, weitere Information während der semantischen Evaluation zu ermitteln und diese zu speichern. In den folgenden Abschnitten werden die Heuristiken und die dafür notwendigen Anpassungen an den jeweiligen Funktionen beschrieben.
\\\\
%\subsection{Heuristiken für die Optimierung der Reihenfolge}
Die folgenden Heuristiken haben zum Ziel, die Reihenfolge, in der die Proxies hinsichtlich der vordefinierten Tests geprüft werden, so anzupassen, dass ein passender Proxy möglichst früh geprüft wird.


\subsection{Beachtung des Matcherratings (LMF)}\label{sec_lmf}
Bei dieser Heuristik, welche den Namen \emph{low matcherrating first} (kurz: LMF) trägt, werden die Mengen von Target-Typen, aus denen die Proxies erzeugt werden, auf der Basis eines so genannten Matcherratings bewertet. Bei dem Matcherrating einer solchen Menge handelt es sich um einen numerischen Wert, auf dessen Basis entschieden werden kann, für welche Menge von Target-Typ die Generierung und Evaluation der Proxies vollzogen werden soll.
\\\\
Um das Matcherrating zu ermitteln, wird für jede Matchingrelation bzw. für jeden Matcher aus Abschnitt \ref{sec_matcher} ein Basisrating vergeben. Folgende Funktion beschreibt das Basisrating für das Matching zweier Typen $S$ und $T$:
\begin{gather*}
\mathit{base(S,T)} :=  \left\{ 
				\begin{array}{l}
					100 \text{ wenn } S \Rightarrow_{exact}  T  \\
					200 \text{ wenn } S \Rightarrow_{gen}  T  \\
					200 \text{ wenn } S \Rightarrow_{spec}  T  \\
					300 \text{ wenn } S \Rightarrow_{contained}  T   \\
					300 \text{ wenn } S \Rightarrow_{container}  T  				
				\end{array}             
	\right.
\end{gather*}
\noindent
Dabei ist zu erwähnen, dass einige der o.g. Matcher über dasselbe Basisrating verfügen. Das liegt daran, dass sie technisch jeweils gemeinsam umgesetzt wurden.\footnote{Der \emph{GenTypeMatcher} und der \emph{SpecTypeMatcher} wurden gemeinsam in der Klasse $\texttt{GenSpecTypeMatcher}$ umgesetzt. Der \emph{ContentTypeMatcher} und der \emph{ContainerTypeMatcher} wurden gemeinsam in der Klasse $\texttt{WrappedTypeMatcher}$ umgesetzt. (siehe angehängter Quellcode)}
\\\\
Wie an der Funktion $\mathit{base}$ zu erkennen ist, wird das Matcherrating für Typen, die über den \emph{StructuralTypeMatcher} gematcht wurden, nicht spezifiziert. Dieses muss berechnet werden. Die Basis dafür bildet ein Matcherrating, welches für die gematchten Methoden ermittelt wird. Hierzu sei die Funktion $\mathit{bases_{method}}$ für zwei Methoden $\mathit{mR}$ und $\mathit{mT}$ mit $\mathit{mR} \Rightarrow_{method} \mathit{mT}$ wie folgt definiert:
\begin{gather*}
\mathit{bases_{method}(mR,mT)} := \begin{array}{l|l}
\mathit{base(ret(mR), ret(mT))} \cup \mathit{ }
&
\{\mathit{pR_1,...,pR_n}\} = \mathit{params(mR)} \wedge \mathit{ }
\\
\bigcup\limits_{i=1}^{n} \mathit{base(pR_i,pT_i)}
&
\{\mathit{pT_1,...,pT_n}\} = \mathit{params(mT)}
\end{array} 
\end{gather*}
\noindent
Darauf aufbauend kann die Funktion $\mathit{mRating}$ für die beiden Methoden $\mathit{mR}$ und $\mathit{mT}$ definiert werden. Hierzu seien folgende Hilfsfunktionen definiert:
\begin{gather*}
\mathit{sum(\{v_1,...v_n\})} = \sum_{i=1}^{n}v_i
\\
\mathit{max(\{v_1,...,v_n\})} = v_{m}| 1 \leq m \leq n  \wedge \forall i \in  \{1,...,n\}: v_i \leq v_{m}
\\    
\mathit{min(\{v_1,...,v_n\})} = v_{m}| 1 \leq m \leq n  \wedge \forall i \in  \{1,...,n\}: v_i \geq v_{m}   
\end{gather*}
\noindent
In dieser Arbeit werden vier Varianten für diese Definition von $\mathit{mRating}$ vorgeschlagen, die in Abschnitt \ref{sec_evalLMF} evaluiert werden sollen.
\paragraph{Variante 1: Durchschnitt ($\mathit{mRating}$)}

\begin{gather*}
\mathit{mRating(mR,mT)} := \frac{\mathit{sum(base_{method}(mR,mT)}}{|\mathit{params(mR)}|+1}
\end{gather*}

\paragraph{Variante 2: Maximum ($\mathit{mRating}$)}

\begin{gather*}
\mathit{mRating(mR,mT)} = \mathit{max(bases_{method}(mR,mT))}
\end{gather*}

\paragraph{Variante 3: Minimum ($\mathit{mRating}$)}

\begin{gather*}
\mathit{mRating(mR,mT)} = \mathit{min(bases_{method}(mR,mT))}
\end{gather*}

\paragraph{Variante 4: Durchschnitt aus Minimum und Maximum ($\mathit{mRating}$)}

\begin{gather*}
\mathit{mRating(mR,mT)} = \frac{\mathit{max(bases_{method}(mR,mT))}+\mathit{min(bases_{method}(mR,mT))}}{2}
\end{gather*}
\noindent
In einem \emph{provided Typ} $P$ sind mitunter mehrere Methoden deklariert, die ein Matching zu einer Methode $m$ aufweisen. Für die Bestimmung des Matcherratings sei hierbei nur das kleinste Matcherrating jener Methoden aus $P$ relevant. Das minimale Matcherrating einer solchen Methode wird durch folgende Funktion beschrieben:
\begin{gather*}
\mathit{minMRating(m, P)} := 
	\begin{array}{l|l}
\mathit{min(mRating(m'_1),}
&
\{\mathit{m'_1,...,m'_n}\} =
\\
\mathit{...,mRating(m'_n))}
&
\mathit{structM_{target}(m, T)}
\end{array}
\end{gather*}
\noindent
Für einen \emph{required Typ} $R$ und einem \emph{provided Typ} $P$ wird die Menge dieser minimalen Matcherratings je Methode $m \in \mathit{structM(R)}$ über folgende Funktion definiert:
\begin{gather*}
\mathit{minMRatings(R,P)} := \left\{
\begin{array}{l|l}
	\mathit{minMRating(m,P)}
	& 
	m \in \mathit{structM(R,P)}
\end{array}
\right\}
\end{gather*}
\noindent
In einer Bibliothek $L$ wird die Ermittlung des Matcherratings eines \emph{required Typs} $R$ und einer Menge von \emph{provided Typen} $\{T_1,...,T_n\}$ mit $\{T_1,...,T_n\} \in \mathit{cover(R,L)}$ über die Funktion $\mathit{rating}$ beschrieben. Auch hierfür werden in dieser Arbeit insgesamt 4 Varianten vorgeschlagen, die in Kapitel \ref{chap_eval} evaluiert werden sollen.
\paragraph{Variante 1: Durchschnitt ($\mathit{rating}$)}

\begin{gather*}
\mathit{rating(R,\{T_1,...,T_n\})} := \frac{\mathit{sum(minMRatings(R,T_1),...,minMRatings(R,T_1))}}{\sum_{i=1}^{n}|\mathit{structM(R,T_i)}|}
\end{gather*}

\paragraph{Variante 2: Maximum ($\mathit{rating}$)}

\begin{gather*}
\mathit{rating(R,\{T_1,...,T_n\})} := \mathit{max(minMRatings(R,T_1),...,minMRatings(R,T_1))}
\end{gather*}

\paragraph{Variante 3: Minimum ($\mathit{rating}$)}

\begin{gather*}
\mathit{rating(R,\{T_1,...,T_n\})} := \mathit{min(minMRatings(R,T_1),...,minMRatings(R,T_1))}\end{gather*}

\paragraph{Variante 4: Durchschnitt aus Minimum und Maximum ($\mathit{rating}$)}

\begin{gather*}
\mathit{rating(R,\{T_1,...,T_n\})} := 
	\frac{\splitfrac{\mathit{min(minMRatings(R,T_1),...,minMRatings(R,T_1))}}
	{+ \mathit{max(minMRatings(R,T_1),...,minMRatings(R,T_1))}}}{2}	
\end{gather*}
\noindent
Da die Funktion $\mathit{rating}$ von $\mathit{mRating}$ abhängt und für $\mathit{mRating}$ 4 Varianten vorgeschlagen wurden, ergeben sich insgesamt 16 Varianten für die Definition von $\mathit{rating}$. Diese Varianten (1.1 - 4.4) sind in der Tabelle \ref{tab_matcherratingvarianten} mit den Kombinationen der Varianten für $\mathit{mRating}$ und $\mathit{rating}$ aufgeführt.
\begin{table}[h!]
\centering
\small
\begin{tabular}{|c|c|c|}
\hline
\hline
\textbf{Variante} & Variante für $\mathit{rating}$ & Variante für $\mathit{mRating}$
\\
\hline
\hline
\textbf{1.1} & 1 & 1 \\
\hline
\textbf{1.2} & 1 & 2 \\
\hline
\textbf{1.3} & 1 & 3 \\
\hline
\textbf{1.4} & 1 & 4 \\
\hline
\textbf{2.1} & 2 & 1 \\
\hline
\textbf{2.2} & 2 & 2 \\
\hline
\textbf{2.3} & 2 & 3 \\
\hline
\textbf{2.4} & 2 & 4 \\
\hline
\textbf{3.1} & 3 & 1 \\
\hline
\textbf{3.2} & 3 &2 \\
\hline
\textbf{3.3} & 3 & 3 \\
\hline
\textbf{3.4} & 3 & 4 \\
\hline
\textbf{4.1} & 4 & 1 \\
\hline
\textbf{4.2} & 4 & 2 \\
\hline
\textbf{4.3} & 4 & 3 \\
\hline
\textbf{4.4} & 4 & 4 \\
\hline
\hline
\end{tabular}
\caption{Varianten für die Ermittlung des Matcherratings einer Menge von \emph{provided Typen}}
 \label{tab_matcherratingvarianten}
\end{table}
\noindent
\\
Zur Anwendung der Heuristik muss das Matcherrating bei der Erzeugung der Proxies aus den jeweiligen Mengen von \emph{provided Typen} beachtet werden. Dabei sollte die Liste der Mengen von \emph{provided Typen}, die über die Funktion $\mathit{targetSets}$ abgebildet wird und über die in der Methode $\texttt{semanticEval}$ iteriert wird, entsprechend dem Matcherrating sortiert werden. Dadurch werden in der Methode $\texttt{evalProxies}$ zuerst die Proxies evaluiert, die auf Basis einer Menge von \emph{provided Typen} mit dem kleinsten Matcherrating erzeugt wurde. Listing \ref{lst_lmf} zeigt die Anpassungen der Methode $\texttt{relevantProxies}$ auf Basis der Implementierung der semantischen Evaluation aus Listing \ref{lst_semEval}. Für die Sortierung der Liste von Proxies wurde in der Methode $\texttt{LMF}$ exemplarisch das Bubble-Sort-Verfahren verwendet.
\begin{lstlisting}[style = pseudo, caption=Semantische Evaluation mit Heuristik LMF, captionpos=b, label=lst_lmf]
function semanticEval( R, T, tests ){
	for( anzahl = 1; anzahl <= $\mathit{maxTargets( R )}$; i++ ){
		targetSets = $\mathit{targetSets( T, anzahl )}$
		sortedSets = LMF( R, targetSets )		
		for( targets : sorted ){
			relProxies = $\mathit{proxies( R, targets )}$
			proxy = evalProxies( relProxies, tests )	
			if( proxy != null ){
				// passenden Proxy gefunden
				return proxy
			}
		}
	}
	// kein passenden Proxy gefunden
	return null;
}

function LMF( R, targets ){
	for	( n=targets.size(); n>1; n--){
		for( i=0; i<n-1; i++){
			if( $\mathit{rating(R,}$ targets[i] $)$ < $\mathit{rating(R,}$ proxies[i+1] $)$ ){
				tmp = targets[i]
				targets[i] = targets[i+1]
				targets[i+1] = tmp
			}
		}
	}	
	return targets
}
\end{lstlisting}


\subsection{Beachtung positiver Tests (PTTF)}\label{sec_pttf}
Das Testergebnis, welches bei Applikation eines Testfalls für einen Proxy ermittelt wird, ist maßgeblich von den Methoden-Delegationen des Proxies abhängig. Jede Methoden-Delegation $\mathit{MD}$ enthält ein Typ in dem die Delegationsmethode spezifiziert ist. Dieser Typ befindet sich im Attribut $\mathit{MD.del.delTyp}$. Im Fall der sturkturellen Proxies, handelt es sich bei diesem Typ um einen der Target-Typen des Proxies.
\\\\
Für einen required Typ $R$ aus einer Bibliothek $L$, kann ein Target-Typ $T$ in den Mengen der möglichen Mengen von Target-Typen $\mathit{cover(R,L)}$ mehrmals auftreten. Dies gilt insbesondere dann, wenn es in $\mathit{cover(R,L)}$ Mengen gibt, deren Mächtigkeit größer ist, als die Mächtigkeit der Menge, in der $T$ enthalten ist. Daher gilt:
\begin{gather*}
\frac{\exists \mathit{TG},\mathit{TG'} \in \mathit{cover(R,L)} : \wedge T \in \mathit{TG} \wedge |\mathit{TG}| < |\mathit{TG'}|}{\exists \mathit{TG''} \in \mathit{cover(R,L)} : |\mathit{TG'}| = |\mathit{TG''}| \wedge T \in \mathit{TG''}}
\end{gather*}
\noindent
Für die in diesem Abschnitt beschriebene Heuristik mit dem Namen \emph{positive tested targets first} (kurz: PTTF) ist das Ergebnis einzelner Tests in Bezug auf einen Proxy $P$ relevant. Es wird davon ausgegangen, dass wenn ein Testfall durch einen Proxy $P$ erfolgreich durchgeführt wird, sollte die Reihenfolge der zu prüfenden Proxies so angepasst werden, dass die Proxies, die einen Target-Typen des Proxies $P$ verwenden, im weiteren Verlauf zuerst geprüft werden.
\\\\
Dafür sind auf Basis von Listing \ref{lst_semEval} mehrere Anpassungen bzgl. der Implementierung der Methode $\texttt{evalProxies}$ von Nöten:
\begin{enumerate}
\item Die Target-Typen der Proxies, mit denen mind. ein Testfall erfolgreich durchgeführt werden konnte, müssen in einer globalen Variable ($\texttt{prioTargets}$) hinterlegt werden.

\item Die Liste der Proxies, die der Methode $\texttt{evalProxies}$ als Parameter übergeben wird, muss so sortiert werden, dass die Proxies, mit den Target-Typen, die in der globalen Variable ($\texttt{prioTargets}$) hinterlegt wurden, zuerst getestet werden. Dies erfolgt wiederum exemplarisch über das Bubble-Sort-Verfahren in der Methode $\texttt{PTTF}$.

\item Die Liste der Proxies, über die innerhalb der Methode $\texttt{evalProxies}$ iteriert wird, kann bzgl. ihrer Reihenfolge bereits dann optimiert werden, wenn mind. einer der Testfälle für den aktuellen Proxy erfolgreich durchgeführt wurde. Dazu müssen jedoch die Proxies, die bereits innerhalb der Methode getestet wurden, in einer lokalen Variable ($\texttt{tested}$) hinterlegt werden. Dann kann die Methode rekursiv mit den Proxies, die noch nicht getestet wurden, aufgerufen werden. So werden die darin enthaltenen Elemente aufgrund der 2. Anpassung erneut sortiert.
\end{enumerate}  
In Listing \ref{lst_pttf} sind die entsprechend Anpassungen und Ergänzungen im Vergleich zu Listing \ref{lst_semEval} zu entnehmen.
\begin{lstlisting}[style = pseudo, caption = Semantische Evaluation mit Heuristik PTTF, captionpos = b, label = lst_pttf]
prioTargets = []

function evalProxies( proxies, tests ){
	tested = []
	sorted = PTTF( proxies )
	for( proxy : sorted ){
		passedTests = 0
		evalProxy( proxy, tests )
		if( passedTests == tests.size ){
			// passenden Proxy gefunden
			return proxy
		}
		else{
			tested.add( proxy )
			if( passedTests > 0 ){
				prioTargets.addAll( proxy.targets )
				// noch nicht evaluierte Proxies ermitteln
				leftProxies = sorted.removeAll( testedProxies )
				return evalProxies( leftProxies, tests )
			}
		}
	}
	// kein passenden Proxy gefunden
	return null
}

function PTTF( proxies ){
	for	( n=proxies.size ; n>1; n--){
		for( i=0; i<n-1; i++){
			targetsFirst = proxies[i].targets
			targetsSecond = proxies[i+1].targets			
			if( !prioTargets.contains( targetsFirst ) && prioTargets.contains( targetsSecond ) ){
				tmp = proxies[i]
				proxies[i] = proxies[i+1]
				proxies[i+1] = tmp
			}
		}
	}
	return proxies	
}
\end{lstlisting}

\subsection{Beachtung fehlgeschlagener Methodenaufrufe (BL\_NMC)}\label{sec_bl_nmc}
Diese Heuristik mit dem Namen \emph{blacklist negative method calls} (kurz: BL\_NMC) beschreibt ein Ausschlussverfahren. Das bedeutet, dass bestimmte Proxies auf der Basis von Erkenntnissen, die während der laufenden semantischen Evaluation entstanden sind, für den weiteren Verlauf ausgeschlossen werden. Dadurch soll die erneute Prüfung eines Proxies, der ohnehin nicht zum gewünschten Ergebnis führt, verhindert werden.
\\\\
Die Heuristik zielt darauf ab, Methoden-Delegationen, die immer fehlschlagen, zu identifizieren. Wurde eine solche Methoden-Delegation gefunden, können alle Proxies, die diese Methoden-Delegation enthalten von der weiteren Exploration ausgeschlossen werden.
\\\\
Die Methoden-Delegationen, die auf der Basis der beiden folgenden Heuristiken aussortiert werden sollen, werden zu diesem Zweck in einer globalen Variable ($\texttt{mdelBlacklist}$) gehalten. Aus einer Liste von Proxies können darauf aufbauend diejenigen Proxies entfernt werden, die eine jener Methoden-Delegationen enthalten. Dabei wird davon ausgegangen, dass die Methoden eines required Typen über den Namen identifiziert werden können.
\\\\
Das Füllen der globalen Variable $\texttt{mdelBlacklist}$ erfolgt in der Methoden $\texttt{evalProxy}$. Die Identifikation der Methoden-Delegationen über die Methodennamen erfolgt in der Methode $\texttt{getMethodDelegations}$. Beide Methoden sind Listing \ref{lst_BL_evalProxy} zu entnehmen.
\begin{lstlisting}[style = pseudo, caption = Evaluierung einzelner Proxies mit BL\_MNC, captionpos = b, label = lst_BL_evalProxy]
function evalProxy( proxy, tests ){
	for( test : T ){	
		if( test.eval( proxy ) ){
			passedTestcases = passedTestcases + 1
		}
		else {
			triedMethodCalls = test.triedMethodCalls
			mDel = getMethodDelegations( proxy, triedMethodCalls )
			mdelBlacklist.add( mDel )
		}		
	}
}

function getMethodDelegations( proxy, methodNames ){
	for( i=0; i < proxy.dels.size; i++ ){
		methodName = proxy.dels[i].call.name
		if( methodNames.containsAll( methodName ) ){
			return proxy.dels[i]
		}
	}
	return null
}
\end{lstlisting}
\noindent
Das Ausschließen bestimmter Proxies erfolgt, indem Elemente aus einer Liste von Proxies entfernt werden. Listing \ref{lst_BL} zeigt die dafür vorgesehene Methode $\texttt{BL}$, welche die Basis-Liste der Proxies im Parameter $\texttt{proxies}$ und die Liste der Kombinationen von Methoden-Delegationen, die die Grundlage für den Ausschluss einzelner Proxies bilden, im Parameter $\texttt{blacklist}$ erwartet.
\begin{lstlisting}[style = pseudo, label = lst_BL, caption=Blacklist-Methode für Heuristil BL\_NMC, captionpos = b]
function BL( proxies, blacklist ){
	filtered = []	
	for( proxy : proxies ){
		blacklisted = false
		for( md : blacklist ){
			if( proxy.dels.contains( md ) ){
				blacklisted = true
				break
			}	
		}
		if( !blacklisted ){
			filtered.add( proxy )
		}
	}
	return filtered
}

\end{lstlisting}
\noindent
Bei dieser Heuristik ist deren Anwendung nach jedem Evaluationsversuch eines einzelnen Proxies sinnvoll. Listing \ref{lst_BL_NMC} zeigt die Anpassungen in der Funktion \emph{evalProxies} aus Listing \ref{lst_semEval} für die Heuristik BL\_NMC. Dabei sei davon auszugehen, dass die oben beschriebene Funktion aus den Listings \ref{lst_BL} und \ref{lst_BL_evalProxy} zur Verfügung steht.
\begin{lstlisting}[style = pseudo, caption=Evaluation mehrere Proxies mit BL\_MNC, captionpos=b, label = lst_BL_NMC]
function evalProxies( proxies, tests ){
	tested = []
	filtered = BL( proxies, mdelBlacklist )
	for( proxy : proxies ){
		passedTestcases = 0
		evalProxy(proxy, tests)
		if( passedTestcases == tests.size ){
			// passenden Proxy gefunden
			return proxy
		}
		else{
			tested.add( proxy )
				// noch nicht evaluierte Proxies ermitteln
			leftProxies = proxies.removeAll( tested )	
			return evalProxies( leftProxies, tests )
		}
	}
	// kein passenden Proxy gefunden
	return null
}
\end{lstlisting}
\noindent
Der Pseudo-Code für die semantische Evaluation mit der Kombination aller genannten Heuristiken ist im Anhang \ref{app_semEvalMitAllenHeuristiken} zu finden.



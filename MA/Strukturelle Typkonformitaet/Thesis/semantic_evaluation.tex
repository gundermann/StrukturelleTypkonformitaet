\section{Semantische Evaluation}
Das Ziel der semantischen Evaluation ist es, einen der Proxies, die aus den Mengen von Target-Typen, die im Rahmen der strukturellen Evaluation erzeugt werden können, hinsichtlich der vordefinierten Testfälle zu evaluieren. Da die gesamte Exploration zur Laufzeit des Programms durchgeführt wird, stellt sie hinsichtlich der nicht-funktionalen Anforderungen eine zeitkritische Komponente dar.
\\\\
Da die Anforderungen an die gesuchte Komponente mit bedacht spezifiziert werden müssen, ist es irrelevant, ob es mehrere Proxies gibt, die hinsichtlich der vordefinierten Testfällen positiv evaluatiert werden können. Es ist ausreichend lediglich ein Proxy zu finden, dessen Semantik zu positiven Ergebnissen hinsichtlich aller vordefinierten Testfälle führt.
\subsection{Besonderheiten der Testfälle}
Bei den vordefinierten Tests handelt es sich auf formaler Ebene um Typen, die eine eval-Methode mit der Struktur $\texttt{boolean eval( proxy )}$ anbieten, welche einen Proxy als Parameter erwartet und ein Objekt vom Typ $\texttt{boolean}$ zurückgibt. Weiterhin verfügt ein Test über ein Attribut $\texttt{triedMethodCalls}$, in dem eine Liste von Methodennamen des Proxies, die bei der Durchführung der eval-Methode aufgerufen wurden, hinterlegt ist.
\\\\
Die Implementierung der eval-Methode ist an folgende Bedingungen geknüpft:
\begin{enumerate}
\item Vor dem Aufruf einer Methode auf dem als Parameter übergebenen Proxy-Objekt, wird der Name der dieser Methode in der Liste im Feld $\texttt{triedMethodCalls}$ ergänzt.
%\item Nach einem fehlgeschlagenen Aufruf einer Methode auf dem als Parameter übergebenen Proxy-Objekt, wird das Feld $\texttt{failedMethod}$ mit dem Namen der fehlgeschlagenen Methode belegt. Zusätzlich wird die eval-Methode direkt danach mit dem Rückgabewert $\texttt{false}$ beendet.
\item Wenn der Proxy den Test erfüllt, wird der Wert $\texttt{true}$ zurückgegeben. Anderenfalls wird der Wert $\texttt{false}$ zurückgegeben.
\end{enumerate}

\begin{example}{xmpl_evalMethode}
In folgendem Listing \ref{lst_examEval} ist eine eval-Methode aufgeführt, die die oben genannten Bedingungen erfüllt. Es sei davon auszugehen, dass der als Parameter übergebene Proxy eine Methode mit der Struktur $\methodForm{Integer}{add}{Integer x, Integer y}$
anbietet. Der Fehlschlag ($\texttt{err}$) dieser Methode wird über einen Try-Catch-Block abgefangen.
\begin{lstlisting}[style = pseudo, label = lst_examEval, caption = Beispielhafte Implementierung einer eval-Methode, captionpos = b]
function eval( proxy ){
	res = 0	
	triedMethodCalls.add( "add" )
	res = proxy.add(1, 1)
	return res == 2;
}
\end{lstlisting}
\end{example}

\subsection{Algorithmus für die semantische Evaluation}\label{sec_semEvalAlgo}
Bei der Exploration soll letztendlich in einer Bibliothek $L$ zu einem vorgegebenen required Type $R$ ein Proxy gefunden werden. Die Mengen der Target-Typen auf deren Basis mehrere Proxies erzeugt werden können, wurden im Abschnitt \ref{sec_anzahlProxies} über $\mathit{cover(R,L)}$ beschrieben. Die in $T = \mathit{cover(R,L)}$ befindlichen Mengen können eine unterschiedliche Anzahl von Target-Typen enthalten. Die maximale Mächtigkeit einer Menge $T_i \in T$ ist gleich der Anzahl der Methoden in $R$.
\begin{gather*}
\mathit{maxTargets(R)} := |\mathit{methoden(R)}|
\end{gather*}
\noindent
In Bezug zur Funktion $\mathit{cover}$ gilt:
\begin{gather*}
\forall T \in \mathit{cover(R,L)} : |T| \leq \mathit{maxTargets(R)}
\end{gather*}
\noindent
\\
Das in dieser Arbeit beschriebene Konzept basiert auf der Annahme, dass der gesamte Anwendungsfall - oder Teile davon - , der mit der vordefinierten Struktur und den vordefinierten Tests abgebildet werden soll, schon einmal genauso oder so ähnlich in dem gesamten System implementiert wurde. Aus diesem Grund kann für die semantische Evaluation davon ausgegangen werden, dass die erfolgreiche Durchführung aller relevanten Tests umso wahrscheinlicher ist, je weniger Target-Typen im Proxy verwendet werden.
\\\\
Sei folgende Funktion für eine Menge von Target-Typen $T \in \mathit{cover(R,L)}$ und eine ganze Zahl $a > 0$ definiert:
\begin{gather*}
\mathit{targetSets(T,a)} := \{T_i | T_i \in T \wedge |T_i| = a\}
\end{gather*}
\noindent
Ausgehend von einer Bibliothek $L$ kann der Algorithmus für die semantische Evaluation der Proxies, die für einen required Typ $R$ mit den Mengen der Target-Typen $T = \mathit{cover(R, L)}$ erzeugt werden können, und der Menge von Tests (Parameter $\texttt{tests}$) wie folgt im Pseudo-Code beschrieben werden. Die globale Variable $\texttt{passedTests}$ enthält dabei die Anzahl der für den aktuell zu überprüfenden Proxy erfolgreich durchgeführten Tests. Außerdem sei davon auszugehen, dass die Funktionen aus Abschnitt \ref{sec_structEval} wie beschrieben definiert sind.
\begin{lstlisting}[style = pseudo, caption = Semantische Evaluation ohne Heuristiken, captionpos = b, label = lst_semEval]
passedTests = 0

function semanticEval( R, T, tests ){
	for( i = 1; i <= $\mathit{maxTargets( R )}$; i++ ){
		relProxies = relevantProxies( R, T, i )
		proxy = evalProxies( relProxies, tests )	
		if( proxy != null ){
			// passenden Proxy gefunden
			return proxy
		}
	}
	// kein passenden Proxy gefunden
	return null;
}

function relevantProxies(R, T, anzahl){
	proxies = []
	targetSets = $\mathit{targetSets( T, anzahl )}$
	for( targets : targetSets ){
		proxies.addAll( $\mathit{proxies( R, targets )}$ )
	}
	return proxies;
}

function evalProxies(proxies, tests){
	for( proxy : proxies ){
		passedTests = 0
		evalProxy(proxy, tests)
		if( passedTests == tests.size ){
			// passenden Proxy gefunden
			return proxy
		}
	}
	// kein passenden Proxy gefunden
	return null
}

function evalProxy(proxy, tests){
	for( test : tests ){
		if( !test.eval( proxy ) ){
			\\ wenn ein Test fehlschlaegt, dann entspricht der 
			\\ Proxy nicht den semantischen Anforderungen
			return
		}
		passedTests = passedTests + 1
	}
}
\end{lstlisting}
Die Dauer der Laufzeit der in Listing \ref{lst_semEval} definierten Funktionen hängt maßgeblich von der Anzahl der Proxies ab, die für den required Typ $R$ in der Bibliothek $L$ erzeugt werden können (siehe auch Abschnitt \ref{sec_anzahlProxies} Funktion $\mathit{proxyCount}$). Im schlimmsten Fall müssen alle Proxies hinsichtlich der vordefinierten Tests erzeugt und evaluiert werden. Um die Anzahl dieser Proxies zu reduzieren, werden die im folgenden Abschnitt beschriebenen Heuristiken verwendet.


\section{Heuristiken}
Die Heuristiken werden an unterschiedlichen Stellen des Algorithmus aus Listing \ref{lst_semEval} eingebaut. Teilweise ist es für die Verwendung einer Heuristik notwendig, weitere Information während der semantischen Evaluation zu ermitteln und diese zu speichern. In den folgenden Abschnitten werden die Heuristiken und die dafür notwendigen Anpassungen an den jeweiligen Funktionen beschrieben.

%\subsection{Heuristiken für die Optimierung der Reihenfolge}
Die folgenden Heuristiken haben zum Ziel, die Reihenfolge, in der die Proxies hinsichtlich der vordefinierten Tests geprüft werden, so anzupassen, dass ein passender Proxy möglichst früh geprüft wird.


\subsection{Beachtung des Matcherratings (LMF)}\label{sec_lmf}
Bei dieser Heuristik, welche den Namen\emph{low matcherrating first} (kurz: LMF) trägt, werden die Proxies auf der Basis eines so genannten Matcherratings bewertet. Bei dem Matcherrating eines Proxies handelt es sich um einen numerischen Wert. Um diesen Wert zu ermitteln, wird für jede Matchingrelation bzw. für jeden Matcher aus Abschnitt \ref{sec_matcher} ein Basisrating vergeben. Folgende Funktion beschreibt das Basisrating für das Matching zweier Typen $S$ und $T$:
\begin{gather*}
\mathit{base(S,T)} :=  \left\{ 
				\begin{array}{l}
					100 | S \Rightarrow_{exact}  T  \\
					200 | S \Rightarrow_{gen}  T  \\
					200 | S \Rightarrow_{spec}  T  \\
					300 | S \Rightarrow_{contained}  T   \\
					300 | S \Rightarrow_{container}  T  				
				\end{array}             
	\right.
\end{gather*}
\noindent
Dabei ist zu erwähnen, dass einige der o.g. Matcher über dasselbe Basisrating erfügen. Das liegt daran, dass sie technisch jeweils gemeinsam umgesetzt wurden.\footnote{Der \emph{GenTypeMatcher} und der \emph{SpecTypeMatcher} wurden gemeinsam in der Klasse $\texttt{GenSpecTypeMatcher}$ umgesetzt. Der \emph{ContentTypeMatcher} und der \emph{ContainerTypeMatcher} wurden gemeinsam in der Klasse $\texttt{WrappedTypeMatcher}$ umgesetzt. (siehe angehängter Quellcode)}
\\\\
Das Matcherrating eines Proxies $P$ wird über die Funktion $\mathit{rating}$ beschrieben. Dieses ist von dem Matcherrating der Methoden-Delegation innerhalb von $P$ abhängig. Das Matcherrating einer Methoden-Delegation ist von den Basisratings der Matcher abhängig, über die die Parameter- und Rückgabe-Typen der aufgerufenen Methode und der Delegationsmethoden gematcht werden können. 
\\\\
Für die Definition von Funktionen gelten im weiteren Verlauf folgende verkürzte Schreibweise in Bezug auf eine Methoden-Delegation $\mathit{MD}$:
\begin{gather*}
	\mathit{pc} := \mathit{MD.call.paramCount}
	\\
	\mathit{cRT} := \mathit{MD.call.returnType}
	\\
	\mathit{dRT} := \mathit{MD.del.returnType}
	\\
	\mathit{cPT} := \mathit{MD.call.paramTypes}
	\\
	\mathit{dPT} := \mathit{MD.del.paramTypes}
	\\
	\mathit{pos} := \mathit{MD.call.posModi}
\end{gather*}
\noindent
Darauf aufbauend sei die Menge der Matcherratings der Paare von Parameter- und Rückgabetypen aus der aufgerufenen Methode und den Delegationsmethode einer Methoden-Delegation $\mathit{MD}$ wie folgt definiert:
\begin{gather*}
\mathit{bases_{MD}(MD)} :=  \mathit{base(dRT, cRT)} \cup \bigcup\limits_{i=0}^{pc-1} \mathit{base(cPT[i],dPT[pos[i]])}
\end{gather*}
\noindent
Das Matcherrating einer Methoden-Delegation $\mathit{MD}$ sei über die Funktion $\mathit{mdRating}$ beschrieben. Für die Definition der beiden Funktionen $\mathit{rating}$ und $\mathit{mdRating}$ gibt es unterschiedliche Möglichkeiten. In dieser Arbeit werden 4 Varianten als Definitionen vorgeschlagen, die in Kapitel \ref{chap_evaluation} untersucht werden.
\\\\
Dazu seien die folgenden Hilfsfunktionen definiert:
\begin{gather*}    
\mathit{sum(v_1,...v_n)} = \sum_{i=1}^{n}v_i
\\\\
\mathit{max(v_1,...,v_n)} = v_{m}| 1 \leq m \leq n  \wedge \forall i \in  \{1,...,n\}: v_i \leq v_{m}
\\\\       
\mathit{min(v_1,...,v_n)} = v_{m}| 1 \leq m \leq n  \wedge \forall i \in  \{1,...,n\}: v_i \geq v_{m}   
\end{gather*}
Für die folgenden Vorschläge zur Definition von $\mathit{rating}$ und $\mathit{mdRating}$ sei $P$ ein struktureller Proxy mit $n$ Methoden-Delegation.
\paragraph{Variante 1: Durchschnitt}

\begin{gather*}
\mathit{mdRating(MD)} = \frac{\mathit{sum(bases_{MD}(MD))}}{\mathit{pc} + 1}
\\\\
\mathit{rating(P)} = \frac{ \mathit{sum(mdRating(P.dels[0]),...,mdRating(P.dels[n-1]))}}{n}
\end{gather*}



\paragraph{Variante 2: Maximum}

\begin{gather*}
\mathit{mdRating(MD)} = \mathit{max(bases_{MD}(MD))}
\\\\
\mathit{rating(P)} = \frac{\mathit{max(mdRating(P.dels[0]),...,mdRating(P.dels[n-1]))}}{n}
\end{gather*}



\paragraph{Variante 3: Minimum}

\begin{gather*}
\mathit{mdRating(MD)} = \mathit{min(bases_{MD}(MD))}
\\\\
\mathit{rating(P)} = \frac{\mathit{min(mdRating(P.dels[0]),...,mdRating(P.dels[n-1]))}}{n}
\end{gather*}

\paragraph{Variante 4: Durchschnitt aus Minimum und Maximum}

\begin{gather*}
\mathit{mdRating(MD)} = \frac{\mathit{max(bases_{MD}(MD))}+\mathit{min(bases_{MD}(MD))}}{2}
\\\\
\mathit{rating(P)} = \frac{\splitfrac{ \mathit{max(mdRating(P.dels[0]),...,mdRating(P.dels[n-1]))}}{+\mathit{min(mdRating(P.dels[0]),...,mdRating(P.dels[n-1]))}}}{2}
\end{gather*}
\noindent
Da die Funktion $\mathit{rating}$ von $\mathit{mdRating}$ abhängt und für $\mathit{mdRating}$ 4 Variante vorgeschlagen wurden, ergeben sich für jede vorgeschlagene Variante für die Definition von $\mathit{rating}$ weitere 4 Varianten. Dadurch sind insgesamt 16 Varianten für die Definition von $\mathit{rating}$ gegeben.
\\\\
Zur Anwendung der Heuristik muss das Matcherrating bei der Iteration über die erzeugten Proxies beachtet werden. Dabei sollte die Liste der Proxies, über die in der Methode $\texttt{evalProxies}$ iteriert wird, entsprechend dem Matcherrating sortiert werden. Eine Sortierung ist nur vor dem Beginn der Iteration in der Methode $\texttt{evalProxies}$  sinnvoll. Listing \ref{lst_lmf} zeigt die Anpassungen der Methode $\texttt{evalProxies}$ auf Basis der Implementierung der semantischen Evaluation aus Listing \ref{lst_semEval}. Für die Sortierung der Liste von Proxies wurde in der Methode $\texttt{LMF}$ exemplarisch das Bubble-Sort-Verfahren verwendet.
\begin{lstlisting}[style = pseudo, caption=Semantische Evaluation mit Heuristik LMF, captionpos=b, label=lst_lmf]
function evalProxies(proxies, tests){
	sorted = LMF( proxies )
	for( proxy : sorted ){
		passedTests = 0
		evalProxy(proxy, tests)
		if( passedTests == tests.size ){
			// passenden Proxy gefunden
			return proxy
		}
	}
	// kein passenden Proxy gefunden
	return null
}

function LMF( proxies ){
	for	( n=proxies.size(); n>1; n--){
		for( i=0; i<n-1; i++){
			if( $\mathit{rating(}$ proxies[i] $)$ < $\mathit{rating(}$ proxies[i+1] $)$ ){
				tmp = proxies[i]
				proxies[i] = proxies[i+1]
				proxies[i+1] = tmp
			}
		}
	}	
	return proxies
}
\end{lstlisting}


\subsection{Beachtung positiver Tests (PTTF)}\label{sec_pttf}
Das Testergebnis, welches bei Applikation eines Testfalls für einen Proxy ermittelt wird, ist maßgeblich von den Methoden-Delegationen des Proxies abhängig. Jede Methoden-Delegation $\mathit{MD}$ enthält ein Typ in dem die Delegationsmethode spezifiziert ist. Dieser Typ befindet sich im Attribut $\mathit{MD.del.delTyp}$. Im Fall der sturkturellen Proxies, handelt es sich bei diesem Typ um einen der Target-Typen des Proxies.\\\\
Für einen required Typ $R$ aus einer Bibliothek $L$, kann ein Target-Typ $T$ in den Mengen der möglichen Mengen von Target-Typen $\mathit{cover(R,L)}$ mehrmals auftreten. Die gilt insbesondere dann, wenn es in $\mathit{cover(R,L)}$ Mengen gibt, deren Mächtigkeit größer ist, als die Mächtigkeit der Menge, in der $T$ enthalten ist. Daher gilt:
\begin{gather*}
\frac{\mathit{TG},\mathit{TG'} \in \mathit{cover(R,L)} \wedge T \in \mathit{TG} \wedge |\mathit{TG}| < |\mathit{TG'}|}{\exists \mathit{TG''} \in \mathit{cover(R,L)} : |\mathit{TG'}| = |\mathit{TG''}| \wedge T \in \mathit{TG''}}
\end{gather*}
\noindent
\paragraph{Beweis:}
%TODO
Sei $R$ ein required Typ aus der Bibliothek $L$. Sei weiterhin $T \in \mathit{TG}$ und $\mathit{TG} \in \mathit{cover(R,L)}$.
\\\\
Für die in diesem Abschnitt beschriebene Heuristik mit dem Namen \emph{positiv tested targets first} (kurz: PTTF) ist das Ergebnis einzelner Tests in Bezug auf einen Proxy $P$ relevant. Es wird davon ausgegangen, dass wenn ein Testfall durch einen Proxy $P$ erfolgreich durchgeführt wird, sollte die Reihenfolge der zu prüfenden Proxies so angepasst werden, dass die Proxies, die einen Target-Typen des Proxies $P$ verwenden, im weiteren Verlauf zuerst geprüft werden.
\\\\
Dafür sind auf Basis von Listing \ref{lst_semEval} mehrere Anpassungen bzgl. der Implementierung der Methode $\texttt{evalProxies}$ von Nöten:
\begin{enumerate}
\item Die Target-Typen der Proxies, mit denen mind. ein Testfall erfolgreich durchgeführt werden konnte, müssen in einer globalen Variable ($\texttt{prioTargets}$) hinterlegt werden.
\item Die Liste der Proxies, die der Methode $\texttt{evalProxies}$ als Parameter übergeben wird, muss so sortiert werden, dass die Proxies, mit den Target-Typen, die in der globalen Variable ($\texttt{prioTargets}$) hinterlegt wurden, zuerst getestet werden. Die erfolgt wiederum exemplarisch über das Bubble-Sort-Verfahren in der Methode $\texttt{PTTF}$.
\item Die Liste der Proxies, über die innerhalb der Methode $\texttt{evalProxies}$ iteriert wird, kann bzgl. ihrer Reihenfolge bereits dann optimiert werden, wenn mind. einer der Testfälle für den aktuellen Proxy erfolgreich durchgeführt wurde. Dazu müssen jedoch die Proxies, die bereits innerhalb der Methode getestet wurden, in einer lokalen Variable ($\texttt{tested}$) hinterlegt werden. Dann kann die Methode rekursiv mit den Proxies, die noch nicht getestet wurden, aufgerufen werden. So werden die darin enthaltenen Elemente aufgrund der 2. Anpassung erneut sortiert.
\end{enumerate}  
In Listing \ref{lst_pttf} sind die entsprechend Anpassungen und Ergänzungen im Vergleich zu Listing \ref{lst_semEval} zu entnehmen.
\begin{lstlisting}[style = pseudo, caption = Semantische Evaluation mit Heuristik PTTF, captionpos = b, label = lst_pttf]
prioTargets = []

function evalProxies( proxies, tests ){
	tested = []
	sorted = PTTF( proxies )
	for( proxy : sorted ){
		passedTests = 0
		evalProxy( proxy, tests )
		if( passedTests == tests.size ){
			// passenden Proxy gefunden
			return proxy
		}
		else{
			tested.add( proxy )
			if( passedTests > 0 ){
				prioTargets.addAll( proxy.targets )
				// noch nicht evaluierte Proxies ermitteln
				leftProxies = sorted.removeAll( testedProxies )
				return evalProxies( leftProxies, tests )
			}
		}
	}
	// kein passenden Proxy gefunden
	return null
}

function PTTF( proxies ){
	for	( n=proxies.size ; n>1; n--){
		for( i=0; i<n-1; i++){
			targetsFirst = proxies[i].targets
			targetsSecond = proxies[i+1].targets			
			if( !prioTargets.contains( targetsFirst ) && prioTargets.contains( targetsSecond ) ){
				tmp = proxies[i]
				proxies[i] = proxies[i+1]
				proxies[i+1] = tmp
			}
		}
	}
	return proxies	
}
\end{lstlisting}

\subsection{Beachtung fehlgeschlagener Methodenaufrufe (BL\_NMC)}\label{sec_bl_mnc}
Diese Heuristik mit dem Namen \emph{blacklist negative method calls} (kurz: BL\_NMC) beschreibt ein Ausschlussverfahren. Das bedeutet, dass bestimmte Proxies auf der Basis von Erkenntnissen, die während der laufenden semantischen Evaluation entstanden sind, für den weiteren Verlauf ausgeschlossen werden. Dadurch soll die erneute Prüfung eines Proxies, der ohnehin nicht zum gewünschten Ergebnis führt, verhindert werden.
\\\\
Die Heuristik zielt darauf ab, Methoden-Delegationen, die immer fehlschlagen, zu identifizieren. Wurde eine solche Methoden-Delegation gefunden, können alle Proxies, die diese Methoden-Delegation enthalten von der weiteren Exploration ausgeschlossen werden.
\\\\
Die Methoden-Delegationen, die auf der Basis der beiden folgenden Heuristiken aussortiert werden sollen, werden zu diesem Zweck in einer globalen Variable ($\texttt{mdelBlacklist}$) gehalten. Aus einer Liste von Proxies können darauf aufbauend diejenigen Proxies entfernt werden, die eine jener Methoden-Delegationen enthalten. Dabei wird davon ausgegangen, dass die Methoden eines required Typen über den Namen identifiziert werden können.
\\\\
Das Füllen der globalen Variable $\texttt{mdelBlacklist}$ erfolgt in der Methoden $\texttt{evalProxy}$. Die Identifikation der Methoden-Delegationen über die Methodennamen erfolgt in der Methoden $\texttt{getMethodDelegations}$. Beide Methode sind Listing \ref{lst_BL_evalProxy} zu entnehmen.
\begin{lstlisting}[style = pseudo, caption = Evaluierung einzelner Proxies mit BL\_MNC, captionpos = b, label = lst_BL_evalProxy]
function evalProxy( proxy, tests ){
	for( test : T ){	
		if( test.eval( proxy ) ){
			passedTestcases = passedTestcases + 1
		}
		else {
			triedMethodCalls = test.triedMethodCalls
			mDel = getMethodDelegations( proxy, triedMethodCalls )
			mdelBlacklist.add( mDel )
		}		
	}
}

function getMethodDelegations( proxy, methodNames ){
	for( i=0; i < proxy.dels.size; i++ ){
		methodName = proxy.dels[i].call.name
		if( methodNames.containsAll( methodName ) ){
			return proxy.dels[i]
		}
	}
	return null
}
\end{lstlisting}
\noindent
Das Ausschließen bestimmter Proxies erfolgt, indem Elemente aus einer Liste von Proxies entfernt werden. Listing \ref{lst_BL} zeigt die dafür vorgesehene Methode $\texttt{BL}$, welche die Basis-Liste der Proxies im Parameter $\texttt{proxies}$ und die Liste der Kombinationen von Methoden-Delegationen, die die Grundlage für den Ausschluss einzelner Proxies bilden, im Parameter $\texttt{blacklist}$ erwartet.
\begin{lstlisting}[style = pseudo, label = lst_BL, caption=Blacklist-Methode für Heuristil BL\_NMC, captionpos = b]
function BL( proxies, blacklist ){
	filtered = []	
	for( proxy : proxies ){
		blacklisted = false
		for( md : blacklist ){
			if( proxy.dels.contains( md ) ){
				blacklisted = true
				break
			}	
		}
		if( !blacklisted ){
			filtered.add( proxy )
		}
	}
	return filtered
}

\end{lstlisting}
\noindent
Bei dieser Heuristik ist deren Anwendung nach jedem Evaluationsversuch eines einzelnen Proxies sinnvoll. Listing \ref{lst_BL_NMC} zeigt die Anpassungen für die Heuristik BL\_NMC basieren auf den Funktionen aus Listing \ref{lst_BLallg}. Dabei sei davon auszugehen, dass die oben beschriebene Funktion aus den Listings \ref{lst_BL} und \ref{lst_BL_evalProxy} zur Verfügung steht.
\begin{lstlisting}[style = pseudo, caption=Evaluation mehrere Proxies mit BL\_MNC, captionpos=b, label = lst_BL_NMC]
function evalProxies( proxies, tests ){
	tested = []
	filtered = BL( proxies, mdelBlacklist )
	for( proxy : proxies ){
		passedTestcases = 0
		evalProxy(proxy, tests)
		if( passedTestcases == tests.size ){
			// passenden Proxy gefunden
			return proxy
		}
		else{
			tested.add( proxy )
				// noch nicht evaluierte Proxies ermitteln
			leftProxies = proxies.removeAll( tested )	
			return evalProxies( leftProxies, tests )
		}
	}
	// kein passenden Proxy gefunden
	return null
}
\end{lstlisting}
\noindent
Der Pseudo-Code für die semantische Evaluation mit der Kombination aller genannten Heuristiken ist im Anhang \ref{app_semEvalMitAllenHeuristiken} zu finden.



\section{Semantische Evaluation}\label{sec_semEval}
Das Ziel der \emph{semantischen Evaluation} ist es, einen der \emph{Proxies}, die aus den Mengen von \emph{Target-Typen}, die im Rahmen der \emph{strukturellen Evaluation} erzeugt werden können, hinsichtlich der vordefinierten Testfälle zu evaluieren. Da der gesamte \emph{Explorationsprozess} zur Laufzeit des jeweiligen Programms durchgeführt wird, stellt sie hinsichtlich der nicht-funktionalen Anforderungen eine zeitkritische Komponente dar.
\\\\
Da die Anforderungen an den gesuchten \emph{Proxy} mit Bedacht spezifiziert werden müssen, ist es irrelevant, ob es mehrere \emph{Proxies} gibt, die hinsichtlich der vordefinierten Testfällen positiv geprüft werden können. Es ist ausreichend lediglich ein \emph{Proxy} zu finden, dessen Semantik zu positiven Ergebnissen hinsichtlich aller vordefinierten Testfälle führt.
\subsection{Besonderheiten der Testfälle}\label{sec_testanforderungen}
Bei den vordefinierten Tests handelt es sich auf formaler Ebene um Typen, die eine $\texttt{eval}$-Methode mit der Struktur $\texttt{boolean eval( proxy )}$ anbieten, welche einen \emph{Proxy} als Parameter erwartet und ein Objekt vom Typ $\texttt{boolean}$ zurückgibt. Weiterhin verfügt ein Test über ein Attribut $\texttt{triedMethodCalls}$, in dem eine Liste von Methodennamen, die bei der Durchführung der $\texttt{eval}$-Methode auf den \emph{Proxies} aufgerufen wurden, hinterlegt ist.
\\\\
Die Implementierung der $\texttt{eval}$-Methode ist an folgende Bedingungen geknüpft:
\begin{enumerate}
\item Vor dem Aufruf einer Methode auf dem als Parameter übergebenen \emph{Proxy}, wird der Name dieser Methode in der Liste im Feld $\texttt{triedMethodCalls}$ ergänzt.
\item Wenn der \emph{Proxy} den Test besteht, wird der Wert $\texttt{true}$ zurückgegeben. Anderenfalls wird der Wert $\texttt{false}$ zurückgegeben.
\end{enumerate}

\begin{example}{xmpl_evalMethode}
In folgendem Listing \ref{lst_examEval} ist eine $\texttt{eval}$-Methode aufgeführt, die die oben genannten Bedingungen erfüllt. Es sei davon auszugehen, dass der als Parameter übergebene \emph{Proxy} eine Methode mit der Struktur $\methodForm{Integer}{add}{Integer, Integer}$
anbietet.
\begin{lstlisting}[style = pseudo, label = lst_examEval, caption = Beispielhafte Implementierung einer $\texttt{eval}$-Methode, captionpos = b]
function eval( proxy ){
	res = 0	
	triedMethodCalls.add( "add" )
	res = proxy.add(1, 1)
	return res == 2;
}
\end{lstlisting}
\end{example}

\subsection{Algorithmus für die semantische Evaluation}\label{sec_semEvalAlgo}
Während des \emph{Explorationsprozesses} soll aus den \emph{provided Typen} in einer Bibliothek $L$ zu einem vorgegebenen \emph{required Type} $R$ ein Proxy generiert und evaluiert werden. Die Mengen der \emph{Target-Typen} auf deren Basis mehrere \emph{Proxies} erzeugt werden können, wurden im Abschnitt \ref{sec_anzahlProxies} über $\mathit{cover(R,L)}$ beschrieben. Die in $\mathit{cover(R,L)}$ befindlichen Mengen können eine unterschiedliche Anzahl von \emph{Target-Typen} enthalten. Die maximale Mächtigkeit einer Menge $T_i \in \mathit{cover(R,L)}$ ist gleich der Anzahl der Methoden in $R$.
\begin{gather*}
\mathit{maxTargets(R)} := |\mathit{methoden(R)}|
\end{gather*}
\noindent
In Bezug zur Funktion $\mathit{cover}$ gilt:
\begin{gather*}
\forall T \in \mathit{cover(R,L)} : |T| \leq \mathit{maxTargets(R)}
\end{gather*}
\noindent
Das in dieser Arbeit beschriebene Konzept basiert auf der Annahme, dass der gesamte Anwendungsfall - oder Teile davon - , der mit der vordefinierten Struktur (\emph{required Typ}) und den vordefinierten Tests abgebildet werden soll, schon einmal genauso oder so ähnlich in dem gesamten System implementiert wurde. Aus diesem Grund kann für die \emph{semantische Evaluation} davon ausgegangen werden, dass die erfolgreiche Durchführung aller relevanten Tests umso wahrscheinlicher ist, je weniger \emph{Target-Typen} im \emph{Proxy} enthalten sind.
\\\\
Die Mengen innerhalb einer Menge $T$ mit einer Mächtigkeit $a < 0$ seien durch folgende Funktion beschrieben:
\begin{gather*}
\mathit{targetSets(T,a)} := 
\left\{\begin{array}{l|l}	
				T_i & T_i \in T \wedge |T_i| = a
		 \end{array}
\right\}
\end{gather*}
\noindent
Ausgehend von einer Bibliothek $L$ kann der Algorithmus für die \emph{semantische Evaluation} der \emph{Proxies}, die für einen \emph{required Typ} $R$ (Parameter $\texttt{R}$) mit den Mengen der \emph{Target-Typen} $\mathit{cover(R, L)}$ (Parameter $\texttt{T}$) erzeugt werden können, und einer Menge von Tests (Parameter $\texttt{tests}$) über die Methode $\texttt{semanticEval}$ wie folgt im Pseudo-Code beschrieben werden. Die globale Variable $\texttt{passedTests}$ enthält dabei die Anzahl der für den aktuell zu überprüfenden \emph{Proxy} erfolgreich durchgeführten Tests. Außerdem sei davon auszugehen, dass die Funktionen aus Abschnitt \ref{sec_proxyGen} wie beschrieben definiert sind.
\begin{lstlisting}[style = pseudo, caption = Semantische Evaluation ohne Heuristiken, captionpos = b, label = lst_semEval]
passedTests = 0

function semanticEval( R, T, tests ){
	for( anzahl = 1; anzahl <= $\mathit{maxTargets( R )}$; i++ ){
		for( targets : $\mathit{targetSets( T, anzahl )}$ ){
			relProxies = $\mathit{proxies( R, targets )}$
			proxy = evalProxies( relProxies, tests )	
			if( proxy != null ){
				// passenden Proxy gefunden
				return proxy
			}
		}
	}
	// kein passenden Proxy gefunden
	return null;
}

function evalProxies(proxies, tests){
	for( proxy : proxies ){
		passedTests = 0
		evalProxy(proxy, tests)
		if( passedTests == tests.size ){
			// passenden Proxy gefunden
			return proxy
		}
	}
	// kein passenden Proxy gefunden
	return null
}

function evalProxy(proxy, tests){
	for( test : tests ){
		if( !test.eval( proxy ) ){
			// wenn ein Test fehlschlaegt, dann entspricht der 
			// Proxy nicht den semantischen Anforderungen
			return
		}
		passedTests = passedTests + 1
	}
}
\end{lstlisting}
Die Dauer der Laufzeit der in Listing \ref{lst_semEval} definierten Funktionen hängt maßgeblich von der Anzahl der \emph{Proxies} ab, die für den \emph{required Typ} $R$ in der Bibliothek $L$ erzeugt werden können (siehe auch Abschnitt \ref{sec_anzahlProxies} Funktion $\mathit{libProxyCount}$). Im schlimmsten Fall müssen alle \emph{Proxies} generiert werden und hinsichtlich der vordefinierten Tests geprüft werden. Um die Anzahl dieser \emph{Proxies} zu reduzieren, werden die im folgenden Abschnitt beschriebenen Heuristiken verwendet.


\section{Heuristiken}\label{sec_heuristics}
Die \Gls{Heuristik}en werden innerhalb des Algorithmus aus Listing \ref{lst_semEval} eingebaut. Teilweise ist es für die Verwendung einer \Gls{Heuristik} notwendig, weitere Information während der \emph{semantischen Evaluation} zu ermitteln und diese zu speichern. In den folgenden Abschnitten werden die \Gls{Heuristik}en und die dafür notwendigen Anpassungen an den jeweiligen Funktionen beschrieben.
\\\\
Die \Gls{Heuristik}en, die in den Abschnitten \ref{sec_lmf} und \ref{sec_pttf} beschrieben werden, haben zum Ziel, die Reihenfolge, in der die \emph{Proxies} hinsichtlich der vordefinierten Tests geprüft werden, so anzupassen, dass ein passender \emph{Proxy} möglichst früh geprüft wird. Die dritte Heuristik, die im Abschnitt \ref{sec_bl_nmc} beschrieben wird, beschreibt ein Ausschlussverfahren.
\\\\
Der Pseudo-Code für die \emph{semantische Evaluation} mit der Kombination aller genannten \Gls{Heuristik}en ist im Anhang \ref{app_semEvalMitAllenHeuristiken} zu finden.


\subsection{Beachtung des Matcherratings (LMF)}\label{sec_lmf}
Bei dieser \Gls{Heuristik}, welche den Namen \emph{low matcherrating first} (kurz: LMF) trägt, werden die Mengen von \emph{Target-Typen}, aus denen die \emph{Proxies} erzeugt werden, auf der Basis eines so genannten \emph{Matcherratings} bewertet. Bei dem \emph{Matcherrating} einer solchen Menge handelt es sich um einen numerischen Wert, auf dessen Basis entschieden werden kann, für welche Menge von \emph{Target-Typ} die Generierung und Evaluation der \emph{Proxies} vollzogen werden soll.
\\\\
Um das \emph{Matcherrating} zu ermitteln, wird für jede Matchingrelation bzw. für jeden Matcher aus Abschnitt \ref{sec_matcher} ein \emph{Basisrating} vergeben. Folgende Funktion beschreibt das \emph{Basisrating} für das Matching zweier Typen $S$ und $T$:
\begin{gather*}
\mathit{base(S,T)} :=  \left\{ 
				\begin{array}{l}
					100 \text{ wenn } S \Rightarrow_{exact}  T  \\
					200 \text{ wenn } S \Rightarrow_{gen}  T  \\
					200 \text{ wenn } S \Rightarrow_{spec}  T  \\
					300 \text{ wenn } S \Rightarrow_{contained}  T   \\
					300 \text{ wenn } S \Rightarrow_{container}  T  				
				\end{array}             
	\right.
\end{gather*}
\noindent
Dabei ist zu erwähnen, dass einige der oben genannten Matcher über dasselbe \emph{Basisrating} verfügen. Das liegt daran, dass sie technisch jeweils gemeinsam umgesetzt wurden.\footnote{Der \emph{GenTypeMatcher} und der \emph{SpecTypeMatcher} wurden gemeinsam in der Klasse $\texttt{GenSpecTypeMatcher}$ umgesetzt. Der \emph{ContentTypeMatcher} und der \emph{ContainerTypeMatcher} wurden gemeinsam in der Klasse $\texttt{WrappedTypeMatcher}$ umgesetzt. (siehe angehängter Quellcode auf dem beiliegenden Datenträger)}
\\\\
Wie an der Funktion $\mathit{base}$ zu erkennen ist, wird das \emph{Matcherrating} für Typen, die über den \emph{StructuralTypeMatcher} gematcht wurden, nicht spezifiziert. Dieses muss berechnet werden. Die Basis dafür bildet ein \emph{Matcherrating}, welches für die gematchten Methoden ermittelt wird. Hierzu sei die Funktion $\mathit{bases_{method}}$ für zwei Methoden $\mathit{mR}$ und $\mathit{mT}$ mit $\mathit{mR} \Rightarrow_{method} \mathit{mT}$ wie folgt definiert:
\begin{gather*}
\mathit{bases_{method}(mR,mT)} := \begin{array}{l|l}
\mathit{base(ret(mR), ret(mT))} \cup \mathit{ }
&
\{\mathit{pR_1,...,pR_n}\} = \mathit{params(mR)} \wedge \mathit{ }
\\
\bigcup\limits_{i=1}^{n} \mathit{base(pR_i,pT_i)}
&
\{\mathit{pT_1,...,pT_n}\} = \mathit{params(mT)}
\end{array} 
\end{gather*}
\noindent
Darauf aufbauend kann die Funktion $\mathit{mRating}$ für die beiden Methoden $\mathit{mR}$ und $\mathit{mT}$ definiert werden. Hierzu seien folgende Hilfsfunktionen definiert:
\begin{gather*}
\mathit{sum(\{v_1,...v_n\})} := \sum_{i=1}^{n}v_i
\\
\mathit{max(\{v_1,...,v_n\})} := v_{m}| 1 \leq m \leq n  \wedge \forall i \in  \{1,...,n\}: v_i \leq v_{m}
\\    
\mathit{min(\{v_1,...,v_n\})} := v_{m}| 1 \leq m \leq n  \wedge \forall i \in  \{1,...,n\}: v_i \geq v_{m}   
\end{gather*}
\noindent
In dieser Arbeit werden vier Varianten für diese Definition von $\mathit{mRating}$ vorgeschlagen, die in Abschnitt \ref{sec_evalLMF} evaluiert werden sollen.
\paragraph{Variante 1: Durchschnitt ($\mathit{mRating}_1$)}

\begin{gather*}
\mathit{mRating_1(mR,mT)} := \frac{\mathit{sum(base_{method}(mR,mT))}}{|\mathit{params(mR)}|+1}
\end{gather*}

\paragraph{Variante 2: Maximum ($\mathit{mRating}_2$)}

\begin{gather*}
\mathit{mRating_2(mR,mT)} = \mathit{max(bases_{method}(mR,mT))}
\end{gather*}

\paragraph{Variante 3: Minimum ($\mathit{mRating}_3$)}

\begin{gather*}
\mathit{mRating_3(mR,mT)} = \mathit{min(bases_{method}(mR,mT))}
\end{gather*}

\paragraph{Variante 4: Durchschnitt aus Minimum und Maximum ($\mathit{mRating}_4$)}

\begin{gather*}
\mathit{mRating_4(mR,mT)} = \frac{\mathit{max(bases_{method}(mR,mT))}+\mathit{min(bases_{method}(mR,mT))}}{2}
\end{gather*}
\noindent
In einem \emph{provided Typ} $T$ sind mitunter mehrere Methoden deklariert, die ein Matching zu einer Methode $m$ aufweisen. Für die Bestimmung des \emph{Matcherratings} sei hierbei nur das kleinste \emph{Matcherrating} jener Methoden aus $P$ relevant. Das \emph{minimale Matcherrating} einer solchen Methode wird durch folgende Funktion beschrieben\footnote{Da die Varianten der Funktion $\mathit{mRating}$ in $\mathit{minMRating}$ flexibel verwendet werden können, wurde für $\mathit{mRating}$ das Subskript $*$ verwendet.}
\begin{gather*}
\mathit{minMRating(m, T)} := 
	\begin{array}{l|l}
\mathit{min(mRating_*(m'_1),}
&
\{\mathit{m'_1,...,m'_n}\} =
\\
\mathit{...,mRating_*(m'_n))}
&
\mathit{structM_{target}(m, T)}
\end{array}
\end{gather*}
\noindent
Für einen \emph{required Typ} $R$ und einem \emph{provided Typ} $T$ wird die Menge dieser \emph{minimalen Matcherratings} je Methode $m \in \mathit{structM(R)}$ über folgende Funktion definiert:
\begin{gather*}
\mathit{minMRatings(R,T)} := \left\{
\begin{array}{l|l}
	\mathit{minMRating(m,T)}
	& 
	m \in \mathit{structM(R,T)}
\end{array}
\right\}
\end{gather*}
\noindent
In einer Bibliothek $L$ wird die Ermittlung des \emph{Matcherratings} eines \emph{required Typs} $R$ und einer Menge von \emph{provided Typen} $\{T_1,...,T_n\}$ mit $\{T_1,...,T_n\} \in \mathit{cover(R,L)}$ über die Funktion $\mathit{rating}$ beschrieben. Auch hierfür werden in dieser Arbeit insgesamt 4 Varianten vorgeschlagen, die in Kapitel \ref{chap_evaluation} evaluiert werden sollen.
\paragraph{Variante 1: Durchschnitt ($\mathit{rating}_1$)}

\begin{gather*}
\mathit{rating_1(R,\{T_1,...,T_n\})} := \frac{\mathit{sum(minMRatings(R,T_1),...,minMRatings(R,T_n))}}{\sum_{i=1}^{n}|\mathit{structM(R,T_i)}|}
\end{gather*}

\paragraph{Variante 2: Maximum ($\mathit{rating}_2$)}

\begin{gather*}
\mathit{rating_2(R,\{T_1,...,T_n\})} := \mathit{max(minMRatings(R,T_1),...,minMRatings(R,T_n))}
\end{gather*}

\paragraph{Variante 3: Minimum ($\mathit{rating}_3$)}

\begin{gather*}
\mathit{rating_3(R,\{T_1,...,T_n\})} := \mathit{min(minMRatings(R,T_1),...,minMRatings(R,T_n))}\end{gather*}

\paragraph{Variante 4: Durchschnitt aus Minimum und Maximum ($\mathit{rating}_4$)}

\begin{gather*}
\mathit{rating_4(R,\{T_1,...,T_n\})} := 
	\frac{\splitfrac{\mathit{min(minMRatings(R,T_1),...,
	minMRatings(R,T_n))}}
	{+ \mathit{max(minMRatings(R,T_1),...,minMRatings(R,T_n))}}}{2}	
\end{gather*}
\noindent
Da die Funktion $\mathit{rating}$ von $\mathit{mRating}$ abhängt und für $\mathit{mRating}$ 4 Varianten vorgeschlagen wurden, ergeben sich insgesamt 16 Varianten für die Definition von $\mathit{rating}$. Diese Varianten (1.1 - 4.4) sind in der Tabelle \ref{tab_matcherratingvarianten} mit den Kombinationen der Varianten für $\mathit{mRating}$ und $\mathit{rating}$ aufgeführt.

\begin{table}[h!]
\centering
\small
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\hline
\textbf{Variante} & 1.1 & 1.2 & 1.3 & 1.4 
& 2.1 & 2.2 & 2.3 & 2.4 
& 3.1 & 3.2 & 3.3 & 3.4 
& 4.1 & 4.2 & 4.3 & 4.4 
\\
\hline
$\mathit{rating}_{*}$& 1 & 1 & 1 & 1
& 2 & 2 & 2 & 2 
& 3 & 3 & 3 & 3 
& 4 & 4 & 4 & 4 
\\
\hline
$\mathit{mRating}_{*}$ & 1 & 2 & 3 & 4 
& 1 & 2 & 3 & 4 
& 1 & 2 & 3 & 4 
& 1 & 2 & 3 & 4 
\\
\hline
\hline
\end{tabular}
\caption{Varianten für die Ermittlung des Matcherratings einer Menge von \emph{provided Typen}}
 \label{tab_matcherratingvarianten}
\end{table}
\noindent
Zur Anwendung der \Gls{Heuristik} muss das \emph{Matcherrating} bei der Generierung der \emph{Proxies} aus den jeweiligen Mengen von \emph{provided Typen} beachtet werden. Dabei sollte die Liste der Mengen von \emph{provided Typen}, die über die Funktion $\mathit{targetSets}$ abgebildet wird (siehe Abschnitt \ref{sec_semEvalAlgo}) und über die in der Methode $\texttt{semanticEval}$ (siehe Listing \ref{lst_semEval}) iteriert wird, entsprechend dem \emph{Matcherrating} sortiert werden. Dadurch werden in der Methode $\texttt{evalProxies}$ (siehe Listing \ref{lst_semEval}) zuerst die \emph{Proxies} generiert und geprüft, die auf Basis einer Menge von \emph{provided Typen} mit dem kleinsten \emph{Matcherrating} erzeugt wurden.
\\\\
Listing \ref{lst_lmf} zeigt die Anpassungen der Methode $\texttt{relevantProxies}$ auf Basis der Implementierung der \emph{semantischen Evaluation} aus Listing \ref{lst_semEval}. Für die Sortierung der Liste von \emph{Proxies} wurde in der Methode $\texttt{LMF}$ exemplarisch das \Gls{bsort}-Verfahren verwendet.

\begin{lstlisting}[style = pseudo, caption=Semantische Evaluation mit Heuristik LMF, captionpos=b, label = lst_lmf]
function semanticEval( R, T, tests ){
	for( anzahl = 1; anzahl <= $\mathit{maxTargets( R )}$; i++ ){
		targetSets = $\mathit{targetSets( T, anzahl )}$
		sortedSets = LMF( R, targetSets )		
		for( targets : sorted ){
			relProxies = $\mathit{proxies( R, targets )}$
			proxy = evalProxies( relProxies, tests )	
			if( proxy != null ){
				// passenden Proxy gefunden
				return proxy
			}
		}
	}
	// kein passenden Proxy gefunden
	return null;
}

function LMF( R, targets ){
	for	( n=targets.size(); n>1; n--){
		for( i=0; i<n-1; i++){
			if( $\mathit{rating(R,}$ targets[i] $)$ < $\mathit{rating(R,}$ targets[i+1] $)$ ){
				tmp = targets[i]
				targets[i] = targets[i+1]
				targets[i+1] = tmp
			}
		}
	}	
	return targets
}
\end{lstlisting}


\subsection{Beachtung positiver Tests (PTTF)}\label{sec_pttf}
Das Testergebnis, welches bei Applikation eines Testfalls für einen \emph{Proxy} ermittelt wird, ist maßgeblich von den \emph{Methoden-Delegationen} des \emph{Proxies} abhängig. Jede \emph{Methoden-Delegation} $\mathit{MD}$ enthält einen Typ in dem die \emph{Delegationsmethode} deklariert wurde. Dieser Typ befindet sich im Attribut $\texttt{MD.del.delTyp}$. Im Fall der \emph{sturkturellen Proxies}, handelt es sich bei diesem Typ um einen der \emph{Target-Typen} des \emph{Proxies}.
\\\\
Für einen \emph{required Typ} $R$ aus einer Bibliothek $L$, kann ein \emph{Target-Typ} $T$ in den Mengen der möglichen Mengen von \emph{Target-Typen} aus $\mathit{cover(R,L)}$ mehrmals auftreten. Dies gilt insbesondere dann, wenn es in $\mathit{cover(R,L)}$ Mengen gibt, deren Mächtigkeit größer ist, als die Mächtigkeit der Menge, in der $T$ enthalten ist. Es gilt also:
\begin{gather*}
\frac{\exists \mathit{TG},\mathit{TG'} \in \mathit{cover(R,L)} :  T \in \mathit{TG} \wedge |\mathit{TG}| < |\mathit{TG'}|}{\exists \mathit{TG''} \in \mathit{cover(R,L)} : |\mathit{TG'}| = |\mathit{TG''}| \wedge T \in \mathit{TG''}}
\end{gather*}
\noindent
Für die in diesem Abschnitt beschriebene \Gls{Heuristik} mit dem Namen \emph{positive tested targets first} (kurz: PTTF) ist das Ergebnis einzelner Tests in Bezug auf einen \emph{Proxy} $P$ relevant. Wenn ein Testfall mit einem \emph{Proxy} $P$ erfolgreich durchgeführt wurde, dann sollte die Reihenfolge der zu prüfenden \emph{Proxies} so angepasst werden, dass die \emph{Proxies}, die einen \emph{Target-Typen} des \emph{Proxies} $P$ verwenden, im weiteren Verlauf zuerst geprüft werden.
\\\\
Dafür sind auf Basis von Listing \ref{lst_semEval} mehrere Anpassungen bzgl. der Implementierung der Methode $\texttt{evalProxies}$ von Nöten:
\begin{enumerate}
\item 
Die \emph{Target-Typen} der \emph{Proxies}, mit denen mind. ein Testfall erfolgreich durchgeführt werden konnte, müssen in einer globalen Variable ($\texttt{prioTargets}$) hinterlegt werden.

\item 
Die Liste der \emph{Proxies}, die der Methode $\texttt{evalProxies}$ als Parameter übergeben wird, muss so sortiert werden, dass die \emph{Proxies}, mit den \emph{Target-Typen}, die in der globalen Variable ($\texttt{prioTargets}$) hinterlegt wurden, zuerst getestet werden. 

\item 
Die Liste der \emph{Proxies}, über die innerhalb der Methode $\texttt{evalProxies}$ iteriert wird, kann bzgl. ihrer Reihenfolge bereits dann optimiert werden, wenn mind. einer der Testfälle für den aktuellen \emph{Proxy} erfolgreich durchgeführt wurde. Dazu müssen jedoch die \emph{Proxies}, die bereits innerhalb der Methode getestet wurden, in einer lokalen Variable ($\texttt{tested}$) hinterlegt werden. Dann kann die Methode rekursiv mit den \emph{Proxies}, die noch nicht getestet wurden, aufgerufen werden. So werden die darin enthaltenen Elemente aufgrund der 2. Anpassung erneut sortiert.
\end{enumerate}  
In Listing \ref{lst_pttf} sind die oben genannten Anpassungen im Vergleich zu Listing \ref{lst_semEval} zu entnehmen. 
\begin{lstlisting}[style = pseudo, caption = Semantische Evaluation mit Heuristik PTTF, captionpos = b, label = lst_pttf]
prioTargets = []

function evalProxies( proxies, tests ){
 tested = []
 sorted = PTTF( proxies )
 for( proxy : sorted ){
  passedTests = 0
  evalProxy( proxy, tests )
  if( passedTests == tests.size ){
   // passenden Proxy gefunden
   return proxy
  }
  else{
   tested.add( proxy )
   if( passedTests > 0 ){
    prioTargets.addAll( proxy.targets )
    // noch nicht evaluierte Proxies ermitteln
    leftProxies = sorted.removeAll( testedProxies )
    return evalProxies( leftProxies, tests )
   }
  }
 }
 // kein passenden Proxy gefunden
 return null
}

function PTTF( proxies ){
 for( n=proxies.size ; n>1; n--){
  for( i=0; i<n-1; i++){
   targetsFirst = proxies[i].targets
   targetsSecond = proxies[i+1].targets			
   if( !prioTargets.contains( targetsFirst ) 
        && prioTargets.contains( targetsSecond ) ){
    tmp = proxies[i]
    proxies[i] = proxies[i+1]
    proxies[i+1] = tmp
   }
  }
 }
 return proxies	
}
\end{lstlisting}

\subsection{Beachtung fehlgeschlagener Methodenaufrufe (BL\_NMC)}\label{sec_bl_nmc}
Diese \Gls{Heuristik} mit dem Namen \emph{blacklist negative method calls} (kurz: BL\_NMC) beschreibt ein Ausschlussverfahren. Das bedeutet, dass bestimmte \emph{Proxies} auf der Basis von Erkenntnissen, die während der \emph{semantischen Evaluation} entstanden sind, für den weiteren Verlauf ausgeschlossen werden. Dadurch soll die Prüfung eines \emph{Proxies}, dessen \emph{Methoden-Delegationen} ohnehin nicht zum gewünschten Ergebnis führen, verhindert werden.
\\\\
Die Heuristik zielt darauf ab, \emph{Methoden-Delegationen}, die immer fehlschlagen, zu identifizieren. Wurde eine solche \emph{Methoden-Delegation} gefunden, können alle \emph{Proxies}, die diese \emph{Methoden-Delegation} enthalten von der weiteren Exploration ausgeschlossen werden.
\\\\
Die \emph{Methoden-Delegationen}, die auf der Basis der folgenden \Gls{Heuristik} aussortiert werden sollen, werden zu diesem Zweck in einer globalen Variable ($\texttt{mdelBlacklist}$) gehalten. Aus einer Liste von \emph{Proxies} können darauf aufbauend diejenigen \emph{Proxies} entfernt werden, die eine jener \emph{Methoden-Delegationen} enthalten. Für die Implementierung wird im Folgenden davon ausgegangen, dass die Methoden eines \emph{required Typen} über den Namen identifiziert werden können.
\\\\
Ausgehend vom Algorithmus der \emph{semantischen Evaluation} (siehe Listing \ref{lst_semEval}) muss die Methode $\texttt{evalProxy}$ für das Füllen der globalen Variable $\texttt{mdelBlacklist}$ angepasst werden. Die Identifikation der \emph{Methoden-Delegationen} über die Methodennamen erfolgt in der Methode $\texttt{getMethodDelegations}$. Beide Methoden sind Listing \ref{lst_BL_evalProxy} zu entnehmen.
\begin{lstlisting}[style = pseudo, caption = Evaluierung einzelner Proxies mit BL\_MNC, captionpos = b, label = lst_BL_evalProxy]
function evalProxy( proxy, tests ){
 for( test : T ){	
  if( test.eval( proxy ) ){
   passedTestcases = passedTestcases + 1
  }
  else {
   triedMethodCalls = test.triedMethodCalls
   mDel = getMethodDelegations( proxy, triedMethodCalls )
   mdelBlacklist.add( mDel )
  }		
 }
}

function getMethodDelegations( proxy, methodNames ){
 for( i=0; i < proxy.dels.size; i++ ){
  methodName = proxy.dels[i].call.name
  if( methodNames.containsAll( methodName ) ){
   return proxy.dels[i]
  }
 }
 return null
}
\end{lstlisting}
\noindent
Das Ausschließen bestimmter \emph{Proxies} erfolgt, indem Elemente aus einer Liste von \emph{Proxies} entfernt werden. Listing \ref{lst_BL} zeigt die dafür vorgesehene Methode $\texttt{BL}$, welche die Basis-Liste der \emph{Proxies} im Parameter $\texttt{proxies}$ und die Liste der Kombinationen von \emph{Methoden-Delegationen}, die die Grundlage für den Ausschluss einzelner \emph{Proxies} bilden, im Parameter $\texttt{blacklist}$ erwartet.
\begin{lstlisting}[style = pseudo, label = lst_BL, caption=Blacklist-Methode für Heuristil BL\_NMC, captionpos = b]
function BL( proxies, blacklist ){
	filtered = []	
	for( proxy : proxies ){
		blacklisted = false
		for( md : blacklist ){
			if( proxy.dels.contains( md ) ){
				blacklisted = true
				break
			}	
		}
		if( !blacklisted ){
			filtered.add( proxy )
		}
	}
	return filtered
}

\end{lstlisting}
\noindent
Bei dieser \Gls{Heuristik} ist deren Anwendung nach jedem Evaluationsversuch eines einzelnen \emph{Proxies} sinnvoll. Listing \ref{lst_BL_NMC} zeigt die Anpassungen in der Funktion $\texttt{evalProxies}$ aus Listing \ref{lst_semEval} für die Heuristik \emph{BL\_NMC}. Dabei sei davon auszugehen, dass die oben beschriebenen Funktionen aus den Listings \ref{lst_BL} und \ref{lst_BL_evalProxy} zur Verfügung stehen.
\begin{lstlisting}[style = pseudo, caption=Evaluation mehrere Proxies mit BL\_MNC, captionpos=b, label = lst_BL_NMC]
function evalProxies( proxies, tests ){
	tested = []
	filtered = BL( proxies, mdelBlacklist )
	for( proxy : proxies ){
		passedTestcases = 0
		evalProxy(proxy, tests)
		if( passedTestcases == tests.size ){
			// passenden Proxy gefunden
			return proxy
		}
		else{
			tested.add( proxy )
				// noch nicht evaluierte Proxies ermitteln
			leftProxies = proxies.removeAll( tested )	
			return evalProxies( leftProxies, tests )
		}
	}
	// kein passenden Proxy gefunden
	return null
}
\end{lstlisting}
\noindent
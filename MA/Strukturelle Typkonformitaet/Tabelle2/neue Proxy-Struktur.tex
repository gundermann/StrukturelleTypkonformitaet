\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{float}
\usepackage{listings}
\usepackage{color}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}

\lstdefinestyle{dsl}{
	 morekeywords={with, subproxy, structproxy, for, simpleproxy, contentproxy, containerproxy, nominalproxy, provided, required, interface, extends, inject, in, posModi},
  showspaces=false,
  showtabs=false,
  breaklines=true,
   literate=
               {-->}{$\rightarrow{}$}{1}
               ,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  basicstyle=\fontsize{9}{10}\selectfont\ttfamily,
  moredelim=[il][\textcolor{pgrey}]{$ $},
  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
}




\newcommand{\matchTyp}[3]
{
#1  
\Rightarrow_{#2}
 #3
}

\begin{document}



\section{Beispiel-Bibliothek}



\begin{lstlisting}[style = dsl]
provided Fire extends Object{}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided ExtFire extends Fire{}
\end{lstlisting}


\begin{lstlisting}[style = dsl]
provided FireState extends Object{
	isActive : boolean
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided Medicine extends Object{
	String getDescription()
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided Injured extends Object{
	void heal(Medicine med)	
}
\end{lstlisting}


\begin{lstlisting}[style = dsl]
provided Patient extends Injured{}
\end{lstlisting}
\begin{lstlisting}[style = dsl]
provided FireFighter extends Object{
	FireState extinguishFire(Fire fire)
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided Doctor extends Object{	
	void heal( Patient pat, Medicine med )
}
\end{lstlisting}


\begin{lstlisting}[style = dsl]
provided InverseDoctor extends Object{	
	void heal( Medicine med, Patient pat )
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided MedCabinet extends Object{
	med : Medicine
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
required PatientMedicalFireFighter {
	void heal( Patient patient, MedCabinet med )
	boolean extinguishFire( ExtFire fire )	
}
\end{lstlisting}

\begin{lstlisting}[caption={Bibliothek \emph{ExampLe} von Typen},captionpos=b, style = dsl]
required MedicalFireFighter {
	void heal( Injured injured, MedCabinet med )
	boolean extinguishFire( ExtFire fire )	
}
\end{lstlisting}\label{lst:libEx}

\newpage

\section{Struktur für die Definition von Proxies}\label{sec:proxygram}
Für die Konvertierung eines Typs $T$ aus einer Menge von \emph{provided Typen} $P$ wird durch Proxies beschrieben. Die Struktur eines Proxies ist Tabelle \ref{tab:grProxies} zu entnehmen. Dabei handelt es sich um Produktionsregeln einer Attributgrammatik. Die dazugehörigen Attribute sind der Tabelle \ref{tab:attrGrProxies} zu entnehmen.\footnote{Die Notation $\mathit{NT}\texttt{.}\text{*}$ in der Spalte \emph{Attribute} beschreibt eine Key-Value-Liste aller Attribute des Nonterminals $\mathit{NT}$, wobei der Attributname als Key und dessen Wert als Value innerhalb der List verwendet wird.}
\begin{table}[H]
\centering
\begin{tabular}{|p{5cm}|p{9cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Erläuterung} \\
\hline
\hline
$\mathit{PROXY} ::=$\newline
$\texttt{proxy } \texttt{for } T$\newline
$ \texttt{with [}\mathit{P_1},...,\mathit{P_n}\texttt{]}$ \newline
$\texttt{\{} \mathit{INJ_1},...,\mathit{INJ_m}$\newline
$\mathit{MDEL_1},...,\mathit{MDEL_k} \texttt{\}}$
 & Ein Proxy wird für ein Typ $T$ mit einer Mengen von \emph{required Typen} $P = \{P_1,...,P_n\}$, einer Menge von Injektionen sowie einer Menge von Methoden-Delegationen erzeugt.\\
\hline
$\mathit{INJ} ::=$\newline 
$\texttt{inject } P_i \texttt{ in } f$ 
& Eine Injektion besteht aus einem Typnamen $P_i$ und einem Feldnamen $f$ einer Feld-Deklaration.\\
\hline
$\mathit{MDEL} ::=$\newline
$CALLM \rightarrow DELM $  & Eine Methodendelegation besteht aus einer aufgerufenen Methode und aus einem Delegationsziel.\\
\hline
$\mathit{CALLM} ::=$\newline $m(\mathit{CP_1},...,\mathit{CP_n}):CR $  & Eine aufgerufene Methode besteht aus dem Namen der Methode \emph{m}, dem Rückgabetyp \emph{CR} und einer Menge von Parametertypen $\{\mathit{CP_1},...,\mathit{CP_n}\}$.\\
\hline
$\mathit{DELM} ::=$\newline 
$\mathit{TREF}\texttt{.}n(\mathit{DP_1},...,\mathit{DP_n}):DR $  
& Die erste Variante eines Delegationsziels besteht aus  dem Namen der Methode \emph{n}, dem Rückgabetyp \emph{DR} und einer Menge von Parametertypen $\{\mathit{DP_1},...,\mathit{DP_n}\}$.\\
\hline
$\mathit{DELM} ::=\texttt{posModi(} \mathit{I_1},...,\mathit{I_n} \texttt{)}$\newline
$\mathit{TREF}\texttt{.}n(\mathit{DP_1},...,\mathit{DP_n}):DR $  
& Die zweite Variante eines Delegationsziels besteht aus einer Menge von Indizies $\{\mathit{I_1},...,\mathit{I_n}\}$, einer Target-Referenz, dem Namen der Methode \emph{n}, dem Rückgabetyp \emph{DR} und einer Menge von Parametertypen $\{\mathit{DP_1},...,\mathit{DP_n}\}$.\\
\hline
$\mathit{TREF} ::= \mathit{P_i}$
& Die erste Variante einer Target-Refernez besteht lediglich aus einem Typ $P_i$.\\
\hline
$\mathit{TREF} ::= \mathit{P_i}\texttt{.}\mathit{f}$
& Die zweite Variante einer Target-Refernez besteht aus einem Typ $P_i$ und einem Feldnamen $f$.\\
\hline
\end{tabular}
\caption{Grammatikregeln mit Erläuterungen für die Definition eines Proxies}
 \label{tab:grProxies}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{|p{6cm}|p{8cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Attribute} \\
\hline
\hline
$\mathit{PROXY} ::=$\newline
$\texttt{proxy } \texttt{for } T$\newline
$ \texttt{with [}\mathit{P_1},...,\mathit{P_n}\texttt{]}$ \newline
$\texttt{\{} \mathit{INJ_1},...,\mathit{INJ_m}$\newline
$\mathit{MDEL_1},...,\mathit{MDEL_k} \texttt{\}}$
& 
$\texttt{type} = \mathit{T}$\newline
$\texttt{targets} = [\mathit{P_1},...,\mathit{P_n}]$\newline
$\texttt{injections} = [\mathit{INJ_1}\texttt{.}\text{*},...,\mathit{INJ_m}\texttt{.}\text{*}]$\newline
$\texttt{delegations} = [\mathit{MDEL_1}\texttt{.}\text{*},...,\mathit{MDEL_k}\texttt{.}\text{*}]$
\\
\hline
$\mathit{INJ} ::=$\newline 
$\texttt{inject } P \texttt{ in } f$ 
& 
$\texttt{target} = \mathit{P}$\newline
$\texttt{field} = \mathit{f}$
\\
\hline
$\mathit{MDEL} ::=$\newline
$\mathit{CALLM} \rightarrow \mathit{DELM} $  
& 
$\texttt{cmName} = \mathit{CALLM}\texttt{.mName}$\newline
$\texttt{cPT} = \mathit{CALLM}\texttt{.paramTypes}$\newline
$\texttt{cRT} = \mathit{CALLM}\texttt{.returnType}$\newline
$\texttt{dmName} = \mathit{DELM}\texttt{.mName}$\newline
$\texttt{dPT} = \mathit{DELM}\texttt{.paramTypes}$\newline
$\texttt{dRT} = \mathit{DELM}\texttt{.returnType}$\newline
$\texttt{posModi} = \mathit{DELM}\texttt{.posModi}$\newline
$\texttt{target} = \mathit{DELM}\texttt{.target}$\newline
$\texttt{delTyp} = \mathit{DELM}\texttt{.delTyp}$
\\
\hline
$\mathit{CALLM} ::=$\newline $m(\mathit{CP_1},...,\mathit{CP_n}):CR $ 
& 
$\texttt{mName} = \mathit{m}$\newline
$\texttt{paramTypes} = \mathit{[CP_1},...,\mathit{CP_n]}$\newline
$\texttt{returnType} = \mathit{CR}$
\\
\hline
$\mathit{DELM} ::=$\newline 
$\mathit{TREF}\texttt{.}n(\mathit{DP_1},...,\mathit{DP_n}):DR $  
&
$\texttt{mName} = \mathit{n}$\newline
$\texttt{paramTypes} = \mathit{[DP_1},...,\mathit{DP_n]}$\newline
$\texttt{returnType} = \mathit{DR}$\newline
$\texttt{posModi} = [0,...,\mathit{n}-1]$\newline
$\texttt{target} = \mathit{TREF}\texttt{.target}$\newline
$\texttt{delTyp} = \mathit{TREF}\texttt{.delTyp}$
\\
\hline
$\mathit{DELM} ::=\texttt{posModi(} \mathit{I_1},...,\mathit{I_n} \texttt{)}$\newline
$\mathit{TREF}\texttt{.}n(\mathit{DP_1},...,\mathit{DP_n}):DR $  
&
$\texttt{mName} = \mathit{n}$\newline
$\texttt{paramTypes} = \mathit{[DP_1},...,\mathit{DP_n]}$\newline
$\texttt{returnType} = \mathit{DR}$\newline
$\texttt{posModi} = \mathit{[I_1},...,\mathit{I_n]}$\newline
$\texttt{target} = \mathit{TREF}\texttt{.target}$\newline
$\texttt{delTyp} = \mathit{TREF}\texttt{.delTyp}$
\\
\hline
$\mathit{TREF} ::= \mathit{P}$
& 
$\texttt{target} = \mathit{P}$\newline
$\texttt{delTyp} = \mathit{P}$
\\
\hline
$\mathit{TREF} ::= \mathit{P}\texttt{.}\mathit{f}$
&
$\texttt{target} = \mathit{P}$\newline
$\texttt{delTyp} = \mathit{feldTyp(f,P)}$
\\
\hline
\end{tabular}
\caption{Grammatikregeln mit Attributen für die Definition eines Proxies}
 \label{tab:attrGrProxies}
\end{table}

\newpage
\subsection{Erläuterung der Semantik von Proxies}
Der Proxy wird zum Zweck der Konvertierung für den Typ $T$ erzeugt. Das bedeutet, dass ein solcher Proxy überall dort verwendet werden kann, wo der Typ $T$ erwartet wird. Der Typ $T$ wird auch als \emph{Source-Typ} bezeichnet. Die Typen aus der Menge der $P$ werden als \emph{Target-Typen} bezeichnet.
\subsubsection{Injektion}
Die Injektion innerhalb eines Proxies, hat zur Folge, dass der Typ aus der Felddeklaration mit dem Feldnamen $f$ in den Typ $P_1$ konvertiert wird. Dieser Konverierung erfolgt wiederum über einen Proxy.
\paragraph{Beispiel:} 
\begin{lstlisting}[style = dsl]
proxy for FireState with [boolean]{
	inject boolean in isActive
}
\end{lstlisting}
\subsubsection{Methoden-Delegation}
Eine Methoden-Delegation beschreibt, wie ein Methodenaufruf delegiert wird. Dabei wird zwischen der aufgerufenen und der delegierten Methoden unterschieden. Die Deklaration einer aufgerufene Methode ist immer im \emph{Source-Typ} zu finden. Die Deklaration der delegierten Methoden ist in dem Typ aus der Target-Referenz zu finden. Hierbei kann es sich um einen \emph{Target-Typen} oder um den Typ eines Feldes aus einem \emph{Target-Typ} handeln.
\paragraph{Beispiel für die Delegation an eine Methode des \emph{Target-Typen}:}
\begin{lstlisting}[style = dsl]
proxy for MedicalFireFighter with [Doctor]{
	heal(Injured, MedCabinet):void --> Doctor.heal(Patient, Medicine):void
}
\end{lstlisting}

\paragraph{Beispiel für die Delegation an eine Methode eines Typ eines Feldes aus dem\emph{Target-Typ}:}
\begin{lstlisting}[style = dsl]
proxy for Medicine with [MedCabinet]{
	getDescription():String --> MedCabinet.med.getDescription():String
}
\end{lstlisting}
Die Parameter der aufgerufenen Methoden werden dabei in die Parameter der Methode aus dem Delegationsziel konvertiert. Nach der Ausführung der Methode aus dem Delegationsziel wird der Rückgabetyp jener Methode in den Rückgabetyp der aufgerufenen Methode konvertiert.\\\\
Bezüglich der Parameter kann es vorkommen, dass neben einer Konvertierung der Typen aus eine Anpassung hinsichtlich der Position vorgenommen werden muss. Ein Proxy für den Typ $\texttt{MedicalFireFighter}$, der mit dem \emph{Target-Typ} $\texttt{InverseDoctor}$ erzeugt wird, gibt ein Beispiel für dieses Szenario.\\\\
Im Vergleich zum Typ $\texttt{Doctor}$ aus einem der beiden obigen Beispiele, ist im Typ $\texttt{InverseDoctor}$ ebenfalls eine Methode $\texttt{heal}$ deklariert. Allerdings ist die Reihenfolge der Parameter umgekehrt. Wenn ein Proxy für den Typ $\texttt{MedicalFireFighter}$, der mit dem \emph{Target-Typ} $\texttt{InverseDoctor}$ erzeugt wird, muss die Reihenfolge der Parameter aus der aufgerufenen Methode der Reihenfolge der Parameter im Delegationsziel angepasst werden. Dies erfolgt über die nach dem Schlüsselwort $\texttt{posModi}$ angegebenen Indizes. Dabei beschreibt der Index die Position des Parameters aus der aufgerufenen Methode. Die Position des Index ist mit der Position des Parameters aus der Methode des Delegationsziels gleichzusetzen.
\paragraph{Beispiel}

\begin{lstlisting}[style = dsl]
proxy for PatientMedicalFireFighter with [InverseDoctor]{
	heal(Patient, MedCabinet):void --> posModi(1,0) InverseDoctor.heal(Medicine, Patient):void
}
\end{lstlisting}



\begin{gather*}
\frac{cPT\texttt{.len} = dPT\texttt{.len} \wedge cPT\texttt{.len} = 0}
{matchedParams(cPT,dPT,pos, \Rightarrow_{PM})}
\end{gather*}

\begin{gather*}
\frac{\forall i \in \{0,...,pos\texttt{.len}-1\}.cPT[pos[i]]\Rightarrow_{PM}dPT[i]}
{matchedParams(cPT,dPT,pos, \Rightarrow_{PM})}
\end{gather*}

\begin{gather*}
\frac{D\texttt{.cRT} \Rightarrow_{RM} D\texttt{.dRT} \wedge matchedParams(D\texttt{.cPT}, D\texttt{.dPT},D\texttt{.posModi}, \Rightarrow_{PM})}
{matchedMDEL(D,\Rightarrow_{RM}, \Rightarrow_{PM})}
\end{gather*}
\\\\
Eine Methoden-Delegation der Form\\
$cm(CP_1,...,CP_n):CR \rightarrow  posModi(I_i,...,I_n) dm(DP_1,...,DP_n):DR$\\
beschreibt, dass der Aufruf der Methoden $cm$ mit den Parametern $CP_1,...,CP_n$ an die Methode $dm$ delegiert wird. Das bedeutet, dass anstelle der Methode $cm$ die Methode $dm$ mit den Parametern $CP_1,...,CP_n$ unter Berücksichtigung der über das Schlüsselwort $\texttt{posModi}$ angegebenen Reihenfolge aufgerufen wird. Dies funktioniert aber nur wenn für alle Parameter $CP_k \in \{CP_1,...,CP_n\}$ mit $1<=k<=n$ Folgendes gilt:\\\\
$CP_k \Rightarrow_{spec} DP_{I_k} \vee CP_k \Rightarrow_{exact} DP_{I_k}$\\\\
Ist diese Voraussetzung für eines der Paare $CP_k$ und $DP_{I_k}$ nicht erfüllt, muss der Typ $CP_k$ in den Typ $DP_{I_k}$ konvertiert werden. Diese Konvertierung erfolgt über einen Proxy, der auf der Basis der passenden Matching-Relation zwischen $CP_k$ und $DP_{I_k}$ ($CP_k \Rightarrow DP_{I_k}$) erzeugt wird. \\\\
Bezogen auf das Beispiel von oben, kann der Parameter-Typ $\texttt{Patient}$ ohne Probleme in die Delegations-Methode für den erwarteten Parameter-Typen $\texttt{Patient}$ verwendet werden, da gilt $\texttt{Patient} \Rightarrow_{spec} \texttt{Patient}$. Bezüglich der anderen Parameter-Typen $\texttt{MedCabinet}$ aus der aufgerufenen Methoden und $\texttt{Medicine}$ aus der delegierten Methode, gilt jedoch keine der oben genannten Bedingungen. Allerdings gilt: $\texttt{MedCabinet} \Rightarrow_{container}\texttt{Medicine}$. Und da die Matching-Relation $\Rightarrow_{container}$ wird ein \emph{Container-Proxy} erzeugt. 
gilt
\newpage
\section{Generierung der Proxies auf Basis von Matchern}
Die Matcher beinhalten die Definition der jeweiligen Matchingrelation ($\Rightarrow$). Auf deren Basis werden Proxies für bestimmte Typen erzeugt. Dabei gibt es unterschiedliche Arten von Proxies. Jede Proxy-Art basiert auf einem anderen Matcher.\\\\
Die Proxies haben eine allgemeine Struktur, die in Abschnitt \ref{sec:proxygram} aufgeführt ist. Um die Regeln für die Generierung der Proxies zu beschreiben, soll davon ausgegangen werden, dass jedes Listen-Attribut aus Tabelle \ref{tab:attrGrProxies} ein Attribut $\texttt{len}$ enthält in dem die Anzahl der in der Liste befindlichen Elemente abgelegt ist.





%\subsection{Generierung der Proxies}
%Zum besseren Verständnis werden die Regeln zur Generierung der Proxies auf das Beispiel aus Abschnitt \ref{xmpl_prxy} angewendet. Da die Proxies verschachtelt sind, erfolgt die beispielhafte Generierung in den folgenden Abschnitten schrittweise parallel zur Beschreibung der Generatoren.
%\begin{itemize}
%\item \emph{Struktureller Proxy}
%\item \emph{Simple-Proxy}
%\item \emph{Sub-Proxy}
%\item \emph{Container-Proxy}
%\item \emph{Content-Proxy}
%\end{itemize}


\begin{table}[H]
\centering
\begin{tabular}{|p{5cm}|p{5cm}|}
\hline
\hline
\centering\textbf{Proxy-Art} & \textbf{Basis-Matchingrelation} \\
\hline
\hline
Sub-Proxy
&  
$\Rightarrow_{spec}$
\\
\hline
Content-Proxy
& 
$\Rightarrow_{content}$
\\
\hline
Container-Proxy
& 
$\Rightarrow_{container}$
\\
\hline
struktureller Proxy
&
$\Rightarrow_{struct}$ \\
\hline
\hline
\end{tabular}
\caption{Proxy-Arten und die dazugehörigen Basis-Matchingrelationen}
 \label{tab:baseMatcher}
\end{table}

\subsubsection{Sub-Proxy}

Die Voraussetzung für die Erzeugung eines \emph{Sub-Proxies} vom Typ $T$ aus einem Target-Typ $T'$ ist $T \Rightarrow_{spec} T'$. Damit ist der \emph{SpecTypeMatcher} der Basis-Matcher für den Sub-Proxy.\\\\
Ein \emph{Sub-Proxy} enthält keinerlei Injektionen, was für einen Proxy $P$ durch durch folgende Regel beschrieben wird.
\begin{gather*}
\frac{\mathit{P\texttt{.injections}}\texttt{.len} = 0}{\mathit{noInjections(P)}}
\end{gather*}
\noindent
Weiterhin enthält ein \emph{Sub-Proxy} genau einen Target-Typ. Für einen Proxy $P$ wird dieser Sachverhalt durch die folgende Regel dargestellt.
\begin{gather*}
\frac{P\texttt{.targets.len} = 1 \wedge P\texttt{.targets}[0] = T'}{\mathit{singleTarget(T')}}
\end{gather*}
Darüber hinaus enthält ein \emph{Sub-Proxy} $P$ eine bestimmte Menge von Methoden-Delegationen. Dabei gilt, dass die aufgerufenen Methode und die Delegationsmethode einer Methoden-Delegation denselben Namen haben.
\begin{gather*}
\frac{DEL\texttt{.cmName} = DEL\texttt{.dmName}}
{\mathit{nominalDel(DEL)}}
\end{gather*}
Die aufgerufene Methode muss dabei im Source-Typ deklariert sein und die Delegationsmethode im Target-Typ.
\begin{gather*}
\frac{\exists m(P_1,...,P_n):R \in \mathit{methoden(P\texttt{.type})}. DEL\texttt{.cmName} = m}
{\mathit{simpleCallMethod(DEL, P)}}
\end{gather*}
\begin{gather*}
\frac{\exists m(P_1,...,P_n):R \in \mathit{methoden(P\texttt{.targets}[0])}. DEL\texttt{.dmName} = m}
{\mathit{simpleDelMethod(DEL, P)}}
\end{gather*}
Zusätzlich müssen die Attribute $\texttt{target}$ und $\texttt{delTyp}$ der Delegationsmethode mit dem Target-Typ des \emph{Sub-Proxies} identisch sein.
\begin{gather*}
\frac{DEL\texttt{.target} = DEL\texttt{.delTyp} \wedge DEL\texttt{.target} = P\texttt{.targets}[0]}
{\mathit{simpleDelTarget(DEL, P)}}
\end{gather*}
Die oben genannten Kriterien werden in folgender Regel zusammengefasst:
\begin{gather*}
\frac{\splitfrac{\mathit{nominalDel(DEL)}\wedge\mathit{simpleCallMethod(DEL,P)\wedge}
}{\mathit{simpleDelMethod(DEL,P)\wedge\mathit{simpleDelTarget(DEL,P)}}}}
{subDelegation(DEL,P)}
\end{gather*}
Innerhalb eines \emph{Sub-Proxies} gibt es für jede Methode $m$ des Target-Typ genau eine Methoden-Delegation, mit der Methode $m$ als Delegationsmethode. Damit lässt sich für einen Proxy $P$ in Bezug auf seine Methoden-Delegationen folgende Regeln formulieren:

\begin{gather*}
\frac{\splitfrac{|\mathit{methoden(P.targets[0])}| = |P.delegations| \wedge}{ \splitfrac{\forall m(P_1,...,P_n):R \in \mathit{methoden(P.targets[0])}.\exists DEL \in P.delegations.}{m = DEL.dmName \wedge subDelegation(DEL,P)
 }}
}
{subDelegations(P)}
\end{gather*}
Die Menge der \emph{Sub-Proxies}, die mit dem Source-Typ $T$ und dem Target-Typ $T'$ erzeugt werden, wird durch die folgende Funktion beschrieben.
\begin{gather*}
\mathit{proxies_{sub}(T,T')} := 
\left\{\begin{array}{l|l}
	P	& P\texttt{.type} = T \wedge\mathit{singleTarget(T')} \wedge \mathit{ }\\
		& \mathit{noInjections(P)} \wedge \mathit{subDelegations(P)} 
		 \end{array}
\right\}
\end{gather*}


\subsubsection{Content-Proxy}

Die Voraussetzung für die Erzeugung eines \emph{Content-Proxies} vom Typ $T$ aus einem Target-Typ $T'$ ist $T \Rightarrow_{content} T'$. Damit ist der \emph{ContentTypeMatcher} der Basis-Matcher für den \emph{Content-Proxy}.\\\\
Ein \emph{Content-Proxy} enthält wiederum keinerlei Injektionen. Weiterhin enthält ein \emph{Content-Proxy}, wie auch der \emph{Sub-Proxy}, genau einen Target-Typ. Ebenfalls identisch zum \emph{Sub-Proxy} ist, dass es sich in den Methoden-Delegationen bei den aufgerufenen Methoden nur um Methoden handeln darf, die im Typ $T$ oder dessen Super-Typ deklariert wurden.\\\\

In Bezug auf das Attribut $\texttt{target}$ und das Attribut $\texttt{delTyp}$ innerhalb einer solchen Methoden-Delegation dürfen diese beiden Typen im \emph{Content-Proxy} nicht identisch sein. Vielmehr muss für das Attribut $\texttt{delTyp}$ und den Source-Typ $T$ ein Matching der Form $T \Rightarrow_{internCont} \texttt{delTyp}$ gelten. Daher gilt für den \emph{Content-Proxy} folgende Regel.
\begin{gather*}
\frac{
\splitfrac{\forall i \in \{0,...,P\texttt{.delegations.len}-1\}.}
{\splitfrac{P\texttt{.delegations}[i]\texttt{.target} \neq P\texttt{.delegations}[i]\texttt{.delTyp} \wedge \mathit{ }}{ P\texttt{.type} \Rightarrow_{internCont} P\texttt{.delegations}[i]\texttt{.delTyp}}}
}
{\mathit{contentTarget(P)}}
\end{gather*}
\noindent
Für welche 

Zuletzt ist zu beachten, dass es nicht mehr Methoden-Delegationen als Methoden im Target-Typ des Proxies gibt. All diese Regeln bzgl. der Methoden-Delegationen eines \emph{Sub-Proxies} werden in folgender Regel zusammengefasst.
\begin{gather*}
\frac{
\splitfrac{P\texttt{.delegations.len} = |\mathit{methoden(P\texttt{.targets}[0])}| \wedge \mathit{ }}
{\mathit{subDelMeth(P)} \wedge \mathit{simpleTarget(P)} \wedge \mathit{callMeth(P)}}
}
{\mathit{subDelegations(P)}}
\end{gather*}
Die Menge der \emph{Sub-Proxies}, die mit dem Source-Typ $T$ und dem Target-Typ $T'$ erzeugt werden durch die folgende Funktion beschrieben.
\begin{gather*}
\mathit{proxies_{sub}(T,T')} := 
\left\{\begin{array}{l|l}
	P	& P\texttt{.type} = T \wedge\mathit{singleTarget(T')} \wedge \mathit{ }\\
		& \mathit{noInjections(P)} \wedge \mathit{subDelegations(P)} 
		 \end{array}
\right\}
\end{gather*}


\subsubsection{Struktureller Proxy}
Ein struktureller Proxy wird für einen \emph{required Typ} $T$ erzeugt. Als Basis für diesen Proxy-Generator fungiert der \emph{StructuralTypeMatcher}.\\\\
Für die Generierung eines solchen Proxies vom Typ $T$ muss sichergestellt werden, dass alle in $T$ enthaltenen
Methoden durch ein oder mehrere \emph{provided Typen} innerhalb der gesamten Bibliothek $L$ gematcht werden. Die folgende Funktion $\mathit{cover}$ beschreibt daher eine Menge von Mengen von \emph{provided Typen}, die für die Erzeugung eines \emph{strukturellen Proxies} für $T$ verwendet werden können.
\begin{gather*}
cover(T,L) := 
\left\{\begin{array}{l|l}
					& P_1 \in L \wedge \text{...} \wedge P_n \in L \wedge \\
					& methoden(T) = structM(T,P_1) \cup \\
	\{P_1,...,P_n\}	& \texttt{...} \cup structM(T, P_n) \wedge \\
					& \mathit{structM(T,P_1)} \neq \emptyset \wedge \\
					& \texttt{...}\wedge \mathit{structM(T,P_n)} \neq \emptyset 
\end{array}\right\}
\end{gather*}
Ausgehend von einer Bibliothek $L$ kann ein \emph{strukureller Proxy} zum \emph{require Typ} $T$ aus einer Menge von \emph{provided Typen} $P$ mit $P \in \mathit{cover(T,L)}$ generiert werden. Dazu werden die Grammatikregeln aus Abschnitt \ref{sec:proxygram}, um Nebenbedingungen erweitert, die Tabelle \ref{tab:structproxy} zu entnehmen sind.
\begin{table}[H]
\centering
\begin{tabular}{|p{4cm}|p{10cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Nebenbedingungen} \\
\hline
\hline
$\mathit{PROXY} ::=$\newline
$\texttt{proxy } \texttt{for } T$\newline
$ \texttt{with [}\mathit{P_1},...,\mathit{P_n}\texttt{]}$ \newline
$\texttt{\{} \mathit{INJECTION_1}$\newline
$...\mathit{INJECTION_m}$\newline
$\mathit{MDEL_1}...\mathit{MDEL_k} \texttt{\}}$
&  
$\mathit{\{P_1},...,\mathit{P_n\}} \in \mathit{cover(T,L)}$\newline
$\mathit{\{INJECTION_1},...,\mathit{INJECTION_m\}}  =\emptyset $\newline
$\forall \mathit{MD} \in \mathit{\{MDEL_1},...,\mathit{MDEL_k\}}.\mathit{MD}.\texttt{target} \in \mathit{\{P_1},...,\mathit{P_n\}} \wedge \mathit{MD}.\texttt{cmethode} \in \mathit{methoden(T)}$\newline
$\forall \mathit{M} \in \mathit{methoden(T)}.\exists \mathit{MD} \in  \mathit{\{MDEL_1},...,\mathit{MDEL_k\}}.\mathit{MD}.\texttt{cmethode} = M$
\\
\hline
$\mathit{INJECTION} ::=$\newline 
$\texttt{inject } P_i \texttt{ in } f$ 
& \\
\hline
$\mathit{MDEL} ::=$\newline
$CALLM \rightarrow DELM $ 
& 
$\texttt{cmethode} = \mathit{CALLM}\texttt{.methode}$\newline
$\texttt{dmethode} = \mathit{DELM}\texttt{.methode}$\newline
$\texttt{target} = \mathit{DELM}\texttt{.target}$
\\
\hline
$\mathit{CALLM} ::=$\newline 
$m(\mathit{CP_1},...,\mathit{CP_n}):CR $  
&
$\texttt{methode} = \mathit{m(CP_1,...,CP_n):CR} $\newline
$\texttt{paramTypen} = \mathit{\{CP_1},...,\mathit{CP_n\}}$\newline
$\texttt{returnTyp} = \mathit{CR}$ \\
\hline
$\mathit{DELM} ::=$\newline 
$\mathit{TREF}\texttt{.}$\newline
$n(\mathit{DP_1},...,\mathit{DP_n}):DR $
&  
$\texttt{methode} = \mathit{n(DP_1,...,DP_n):DR} $\newline
$\texttt{paramTypen} = \mathit{\{DP_1},...,\mathit{DP_n\}}$\newline
$\texttt{returnTyp} = \mathit{DR}$ \newline
$\texttt{target} = \mathit{TREF}\texttt{.typ}$ \\
\hline
\hline
\end{tabular}
\caption{Grammatikregeln und Nebenbedingungen für die Definition eines strukturellen Proxies}
 \label{tab:structproxy}
\end{table}

\paragraph{Beispiel:}
Bezogen auf das Beispiel aus Abschnitt \ref{xmpl_prxy} soll ein \emph{struktureller Proxy} für den \emph{required Typ} $\texttt{MedicalFireFighter}$ aus den \emph{provided Typen} $\texttt{FireFighter}$ und $\texttt{Doctor}$ generiert werden. Dazu gelte folgende Bedingung:
\begin{gather*}
	\text{\{}\texttt{FireFighter},\texttt{Doctor} \text{\}} \in \mathit{cover(\texttt{MedicalFireFighter}, ExampLe)}
\end{gather*}
Die Generierung der \emph{strukturellen Proxies} erfolgt dann in folgenden Schritten, beginnend mit dem Nichtterminal $\mathit{STRUCTPROXY}$. Bei jedem Schritt werden ein oder mehrere Nichtterminal ersetzt und die Attribute aus den Nebenbedingungen soweit wie möglich zugewiesen.
\begin{gather*}
\begin{array}{l|l}
	\mathit{STRUCTPROXY} & \mathit{typ(STRUCTPROXY)} = \texttt{MedicalFireFighter}
\end{array}
\end{gather*}
\begin{gather*}
\begin{array}{l|l}
	\texttt{structproxy for MedicalFireFighter} & \mathit{typ(TARGET_1)} = \texttt{FireFighter}\\
	\texttt{\{} \mathit{TARGET_1} & \mathit{typ(TARGET_2)} = \texttt{Doctor} \\
	 \mathit{TARGET_2} \text{\}} &
\end{array}
\end{gather*}

\begin{gather*}
\begin{array}{l|l}
\texttt{structproxy for MedicalFireFighter} & \\
\texttt{\{} \texttt{FireFighter} \texttt{\{} & \\
\mathit{MDEL_1}\texttt{\}} & \\
\texttt{Doctor} \texttt{\{} & \\
\mathit{MDEL_2}\texttt{\}} \text{\}} &
\end{array}
\end{gather*}
\begin{gather*}
\begin{array}{l|l}
\texttt{structproxy for MedicalFireFighter} & \\
\texttt{\{} \texttt{FireFighter} \texttt{\{} & \\
\mathit{CALLM_1} \rightarrow \mathit{DELM_1}\texttt{\}} & \\
\texttt{Doctor} \texttt{\{} & \\
\mathit{CALLM_2} \rightarrow \mathit{DELM_2}\texttt{\}} \text{\}} &
\end{array}
\end{gather*}

\subsubsection{Container-Proxy}
\subsubsection{Content-Proxy}

\begin{gather*}
\frac{\mathit{INJS}\texttt{.len} = 0}{\mathit{contentInjections(INJS)}}
\end{gather*}
\begin{gather*}
\frac{\mathit{TARS}\texttt{.len} = 1 \wedge T' = \mathit{TARS}[0]}{\mathit{contentTargets(TARS,T,T')}}
\end{gather*}

\begin{gather*}
\frac{\mathit{dTypes}\texttt{.len} = 0 \wedge \mathit{cTypes}\texttt{.len} = 0}{\mathit{contentParamTypes(dTypes, cTypes)}}
\end{gather*}

\begin{gather*}
\frac{\forall i \in \mathit{\{0},...,\mathit{dTypes\texttt{.len}-1\}}.\mathit{match_{simple}(dTypes[i], cTypes[i])} }{\mathit{contentParamTypes(dTypes, cTypes)}}
\end{gather*}

\begin{gather*}
\frac{\mathit{DELS}\texttt{.len} > 0 \wedge \forall \mathit{i} \in \mathit{\{0,...,DELS\texttt{.len}-1\}}.\mathit{contentDelegation(DELS[i],T,T')}}{\mathit{contentDelegations(DELS,T,T')}}
\end{gather*}

\begin{gather*}
\frac{\splitfrac{\exists \mathit{m(P_1,...,P_n):R} \in \mathit{methoden(T).\mathit{DEL}\texttt{.cmName} = m \wedge}}
{\splitfrac{ \mathit{DELS}[i]\texttt{.dmName} = m \wedge \mathit{DELS}[i]\texttt{.delTyp} = \mathit{DELS}[i]\texttt{.target} \wedge \mathit{DELS}[i]\texttt{.target} = T' \wedge}{\splitfrac{\mathit{match_{simple}(\mathit{DELS}[i]\texttt{.creturnType}, \mathit{DELS}[i]\texttt{.dreturnType})}\wedge }
{ \mathit{contentParamTypes(d\texttt{.dParamTypes}, d\texttt{.cParamTypes})}}
}}}
{\mathit{contentDelegation(DEL,T,T')}}
\end{gather*}


\begin{gather*}
proxy_{content}(T,T') := 
\left\{\begin{array}{l|l}
		& \mathit{match_{content}(T,T')} \wedge \\
		& P\texttt{.type} = T \wedge \\
P		& \mathit{contentTargets(P\texttt{.targets},T,T')} \\
		& \mathit{contentInjections(P\texttt{.injections})}  \wedge \\
		& \mathit{contentDelegations(P\texttt{.delegations},T,T')}
\end{array}
\right\}
\end{gather*}

\subsubsection{Sub-Proxy}

\begin{gather*}
\frac{\mathit{INJS}\texttt{.len} = 0}{\mathit{subInjections(INJS)}}
\end{gather*}
\begin{gather*}
\frac{\mathit{TARS}\texttt{.len} = 1 \wedge T' = \mathit{TARS}[0]}{\mathit{subTargets(TARS,T,T')}}
\end{gather*}

\begin{gather*}
\frac{\mathit{dTypes}\texttt{.len} = 0 \wedge \mathit{cTypes}\texttt{.len} = 0}{\mathit{subParamTypes(dTypes, cTypes)}}
\end{gather*}

\begin{gather*}
\frac{\forall i \in \mathit{\{0},...,\mathit{dTypes\texttt{.len}-1\}}.\mathit{match_{simple}(dTypes[i], cTypes[i])} }{\mathit{subParamTypes(dTypes, cTypes)}}
\end{gather*}

\begin{gather*}
\frac{\splitfrac{\forall \mathit{m(P_1,...,P_n):R} \in \mathit{methoden(T')}.\exists d \in \mathit{DELS}.}
{\splitfrac{d\texttt{.cmName} = m \wedge d\texttt{.dmName} = m \wedge d\texttt{.delTyp} = d\texttt{.target} \wedge d\texttt{.target} = T' \wedge}{\splitfrac{\mathit{match_{simple}(d\texttt{.creturnType}, d\texttt{.dreturnType})}\wedge }
{ \mathit{subParamTypes(d\texttt{.dParamTypes}, d\texttt{.cParamTypes})}}
}}}
{\mathit{subDelegations(DELS,T,T')}}
\end{gather*}


\begin{gather*}
proxy_{sub}(T,T') := 
\left\{\begin{array}{l|l}
		& \mathit{match_{spec}(T,T')} \wedge \\
		& P\texttt{.type} = T \wedge \\
P		& \mathit{subTargets(P\texttt{.targets},T,T')} \\
		& \mathit{subInjections(P\texttt{.injections})}  \wedge \\
		& \mathit{subDelegations(P\texttt{.delegations},T,T')}
\end{array}
\right\}
\end{gather*}


\subsubsection{Simple-Proxy}



\begin{gather*}
\frac{T \Rightarrow_{exact} T' \vee T \Rightarrow_{gen} T'}{\mathit{match_{genExact}(T,T')}}
\end{gather*}

\begin{gather*}
\frac{T \Rightarrow_{exact} T' \vee T \Rightarrow_{spec} T'}{\mathit{match_{specExact}(T,T')}}
\end{gather*}
\begin{gather*}
\frac{\mathit{INJS}\texttt{.len} = 0}{\mathit{noInjections(INJS)}}
\end{gather*}
\begin{gather*}
\frac{\mathit{TARS}\texttt{.len} = 1 \wedge T' = \mathit{TARS}[0]}{\mathit{singleTarget(TARS,T')}}
\end{gather*}

\begin{gather*}
\frac{\mathit{superTypes}\texttt{.len} = 0 \wedge \mathit{subTypes}\texttt{.len} = 0}{\mathit{simpleParamTypes(superTypes, subTypes)}}
\end{gather*}

\begin{gather*}
\frac{\splitfrac{\forall i \in \mathit{\{0},...,\mathit{D\texttt{.cParamTypes.len}-1\}}.}{\mathit{match_{specExact}(D\texttt{.cParamTypes}[i], D\texttt{.dParamTypes}[i])}}
}
{\mathit{simpleParamTypes(D)}}
\end{gather*}

\begin{gather*}
\frac{\mathit{match_{genExact}(D\texttt{.creturnType}, D\texttt{.dreturnType})} }{\mathit{simpleReturnTypes(D)}}
\end{gather*}

\begin{gather*}
\frac{\splitfrac{D\texttt{.cmName} = D\texttt{.dmName} \wedge D\texttt{.delTyp} = D\texttt{.target} \wedge D\texttt{.target} = T' \wedge}
{\mathit{simpleReturnTypes(D) \wedge \mathit{simpleParamTypes(D)}}}
}{\mathit{simpleDelegation(D,T,T')}}
\end{gather*}


\begin{gather*}
\frac{\splitfrac{\forall \mathit{m(P_{c1},...,P_{cn}):R_c} \in \mathit{methoden(T)}.\exists d \in \mathit{DELS}.}
{\splitfrac{callMethod(m,[P_{c1},...,P_{cn}],R_c,d) \wedge }
{\exists m(P_{d1},...P_{dn}):R_{d} \in \mathit{methoden(T')}.\mathit{delMethod(m,[P_{d1},...,P_{dn}],R_d,d)}
}}}
{\mathit{simpleDelegations(DELS,T,T')}}
\end{gather*}

\begin{gather*}
\frac{\splitfrac{\forall \mathit{m(P_1,...,P_n):R} \in \mathit{methoden(T)}.\exists d \in \mathit{DELS}.}
{\splitfrac{d\texttt{.cmName} = m \wedge d\texttt{.dmName} = m \wedge d\texttt{.delTyp} = d\texttt{.target} \wedge d\texttt{.target} = T' \wedge}{\splitfrac{\mathit{match_{simple}(d\texttt{.creturnType}, d\texttt{.dreturnType})}\wedge }
{ \mathit{simpleParamTypes(d\texttt{.dParamTypes}, d\texttt{.cParamTypes})}}
}}}
{\mathit{simpleDelegations(DELS,T,T')}}
\end{gather*}


\begin{gather*}
proxy_{simple}(T,T') := 
\left\{\begin{array}{l|l}
		& \mathit{match_{genExact}(T,T')} \wedge \\
		& P\texttt{.type} = T \wedge \\
P		& \mathit{singleTarget(P\texttt{.targets},T')} \\
		& \mathit{noInjections(P\texttt{.injections})}  \wedge \\
		& \mathit{simpleDelegations(P\texttt{.delegations},T,T')}
\end{array}
\right\}
\end{gather*}


Ein \emph{Simple-Proxy} kann sowohl auf der Basis des \emph{ExactTypeMatchers} als auch auf Basis des \emph{GenTypMatchers} generiert werden. Die für den \emph{Simple-Proxy} relevanten Grammatikregeln aus Abschnitt \ref{sec:proxygram} werden für die Generierung noch um Nebenbedingungen erweitert. Die vollständige Liste der Regeln und Nebenbedingungen für den \emph{Simple-Proxy} ist Tabelle \ref{tab:simpleproxy} zu entnehmen.

\begin{table}[H]
\centering
\begin{tabular}{|p{4cm}|p{10cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Nebenbedingungen} \\
\hline
\hline
$\mathit{STPROXY} ::= NPX$ &
$\mathit{typ(STPROXY)}=\mathit{typ(NPX)}$\newline
$\mathit{targetTyp(STPROXY)} = \mathit{targetTyp(NPX)}$\\
\hline
$\mathit{NPX} ::=$ \newline $\texttt{simpleproxy } \texttt{for } P$ & 
$\mathit{targetTyp(NPX)} \Rightarrow_{exact} P $\newline
$\mathit{typ(NPX)}=P$\newline
$\mathit{methoden(NPX)} = \mathit{methoden(P)}$\\
\hline
$\mathit{NPX} ::=$ \newline $\texttt{simpleproxy } \texttt{for } P$ & 
$\mathit{targetTyp(NPX)} \Rightarrow_{gen} P $\newline
$\mathit{typ(NPX)}=P$\newline
$\mathit{methoden(NPX)} = \mathit{methoden(P)}$
\\
\hline
\hline
\end{tabular}
\caption{Regeln und Nebenbedingungen für Simple-Proxies}
 \label{tab:simpleproxy}
\end{table}


Als Beispiel wird von dem Matching ausgegangen, welches auch bei der Beschreibung des \emph{ExactTypeMatchers} (Abschnitt \ref{sec:exacttypematcher}) angeführt wurde:
\begin{gather*}
\texttt{Fire} \Rightarrow_{exact} \texttt{Fire}
\end{gather*}

 
Der \emph{Simple-Proxy} basiert auf zwei Matchern, von denen 
Die Basis für den \emph{Simple-Proxy} sind sowohl der \emph{•}

\section{alter kram}
\subsection{StructuralTypeMatcher}

Ein struktureller Proxy für ein \emph{required Interface} $R$ aus einer Menge von  \emph{provided Typen} $P$ wird durch folgende Regeln und Nebenbedingungen beschrieben:
\begin{table}[H]
\centering
\begin{tabular}{|p{4cm}|p{10cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Nebenbedingungen} \\
\hline
\hline
$\mathit{STRUCTPROXY} ::=$\newline $\texttt{structproxy } \texttt{for } R$\newline$ \texttt{\{}TARGET_1 \texttt{ ... }$ \newline
$ TARGET_n\texttt{\}}$ & $typ(\mathit{STRUCTPROXY})=R$\newline
$methoden(\mathit{STRUCTPROXY}) = $\newline
 $\mathit{cmethoden(TARGET_1)} \cup \texttt{...} \cup \mathit{cmethoden(TARGET_n)} $\newline
$methoden(R) = methoden(\mathit{STRUCTPROXY})$\\
\hline
$\mathit{TARGET} ::=$\newline $P \texttt{ \{}MDEL_1 \texttt{ ...}$\newline
$ MDEL_n\texttt{\}}$ &
$\mathit{typ(TARGET)} = P$ \newline
$\mathit{cmethoden(TARGET)} = $\newline
 $\mathit{cmethode(MDEL_1)} \cup \texttt{...} \cup \mathit{cmethode(MDEL_n)}$ \newline
$\mathit{dmethoden(TARGET)} =  $\newline 
 $\mathit{dmethode(MDEL_1)} \cup \texttt{...} \cup \mathit{dmethode(MDEL_n)}$ \newline
 $\mathit{dmethoden(TARGET)} \subseteq \mathit{methoden(P)} $ \\
\hline
$\mathit{MDEL} ::= $\newline
$ CALLM \rightarrow DELM $  & 
$\mathit{cmethode(MDEL}) = \mathit{methode(CALLM)}$\newline
$\mathit{dmethode(MDEL}) = \mathit{methode(DELM)}$\newline
$\mathit{paramTargetTyp(DELM)} = \mathit{paramTyp(CALLM)}$\newline
$\mathit{returnTargetTyp(CALLM)} = \mathit{returnTyp(DELM)}$
\\
\hline
$\mathit{CALLM} ::=$\newline $m(SP):STPROXY $  &
$SR = \mathit{typ(STPROXY)} $\newline
$\mathit{methode(CALLM)} = \mathit{m(SP):SR} $\newline
$\mathit{paramTyp(CALLM) = SP}$\newline
$\mathit{targetTyp(STPROXY) = returnTargetTyp(CALLM)}$ \\
\hline
$\mathit{DELM} ::=$\newline $n(STPROXY):R $  & 
$DP = \mathit{typ(STPROXY)} $\newline
$\mathit{methode(DELM)} = \mathit{n(DP):R} $\newline
$\mathit{returnTyp(DELM) = R}$\newline
$\mathit{targetTyp(STPROXY) = paramTargetTyp(DELM)}$ \\
\hline
\hline
\end{tabular}
\caption{Grammatik für die Definition eines Proxies}
 \label{tab:eIShort}
\end{table}
\noindent
Regeln für das Nonterminal \emph{STPROXY} unterliegen Nebenbedingungen, die teilweise erst unter Zuhilfenahme der folgenden Matcher erfüllt werden können.


\subsection{SpecTypeMatcher}
Ein Proxy für einen Typ $T$, der mit einem Target-Typ $T'$ mit $T \Rightarrow_{spec} T'$ erzeugt werden soll, ist ein \emph{Sub-Proxy} und wird durch die folgenden Regeln und Nebenbedingungen beschrieben: 
\begin{table}[H]
\centering
\begin{tabular}{|p{5cm}|p{9cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Nebenbedingungen} \\
\hline
\hline
$\mathit{NPX} ::=$ \newline $\texttt{subproxy } \texttt{for } P$\newline $\texttt{with } P' \texttt{ \{}\mathit{NOMMDEL_1}$\newline
$ \texttt{... }\mathit{NOMMDEL_n}\texttt{\}}$ & 
$\mathit{targetTyp(NPX)} = P'$\newline
$\mathit{typ(NPX)} = P$\newline
$P \Rightarrow_{spec} P'$\newline
$\mathit{methoden(NPX)} = \mathit{cmethode(NOMMDEL_1)} \cup $\newline
$\texttt{...} \cup \mathit{cmethode(NOMMDEL_n)}$ \newline
$\mathit{methoden(NPX)} \subseteq \mathit{methoden(P)}  $\newline 
$\mathit{methoden(P')} \supseteq \mathit{dmethode(NOMMDEL_1)} \cup  $\newline 
$\texttt{...} \cup \mathit{dmethode(NOMMDEL_n)}$ 
\\
\hline
$\mathit{NOMMDEL} ::=$\newline
$\mathit{m(SP):SR} \rightarrow$\newline
$ \mathit{m(TP):TR} $  &
$SP >= TP$\newline
$SR <= TR$\newline
$\mathit{cmethode(MOMMDEL)} = \mathit{m(SP):SR}$\newline
$\mathit{dmethode(MOMMDEL)} = \mathit{m(TP):TR}$ \\
\hline
\hline
\end{tabular}
\caption{Regeln und Nebenbedingungen für Sub-Proxies}
 \label{tab:subAttr}
\end{table}
\subsection{ContentTypeMatcher}
Die Matchingrelation für diesen Matcher wird durch folgende Regel beschrieben:
\begin{gather*}
\frac{\exists f:T''\in felder(T'). T \Rightarrow_{internCont} T''}{T \Rightarrow_{content} T'}
\end{gather*}
Für die Relation $\Rightarrow_{internCont}$ gilt dabei:
\begin{gather*}
\frac{T \Rightarrow_{exact} T' \vee T \Rightarrow_{gen} T' \vee
T \Rightarrow_{spec} T'  }{T \Rightarrow_{internCont} T'}
\end{gather*}
Ein Proxy für einen Typ $P$, der mit einem Target-Typ $P'$ mit $P \Rightarrow_{content} P'$ erzeugt werden soll, ist ein \emph{Content-Proxy} und wird durch die folgenden Regeln und Nebenbedingungen beschrieben:
\begin{table}[H]
\centering
\begin{tabular}{|p{4cm}|p{10cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Nebenbedingungen} \\
\hline
\hline
$\mathit{STPROXY} ::=$\newline $\texttt{contentproxy }  \texttt{for } P$\newline $\texttt{with } P' \texttt{ \{}CEMDEL_1$\newline
$\texttt{... } CEMDEL_n\texttt{\}}$ &
$\mathit{typ(STPROXY)}= P$\newline
$\mathit{targetTyp(STPROXY)}= P'$\newline
$P \Rightarrow_{content} P'$\newline
$\mathit{methoden(STPROXY)} = \mathit{cmethode(CEMDEL_1)} \cup $\newline
$\texttt{...} \cup \mathit{cmethode(CEMDEL_n)}$ \newline
$\mathit{methoden(STPROXY)} \subseteq \mathit{methoden(P)}  $\newline
$\mathit{containerType(CEMDEL_1)} = P'$ \newline
$ \texttt{... } \mathit{containerType(CEMDEL_n)} = P' $ \\
\hline
$\mathit{CEMDEL} ::=$\newline
$\mathit{CECALLM} \rightarrow$\newline
$\mathit{f.CEDELM} $  &
$\mathit{f:FT} \in \mathit{felder(containerType(CEMDEL))}$ \newline
$\mathit{methode(CEDELM)} \in \mathit{methoden(FT)} $\newline
$\mathit{paramTargetTyp(CEDELM)} = \mathit{paramTyp(CECALLM)}$\newline
$\mathit{returnTargetTyp(CECALLM)} = \mathit{returnTyp(CEDELM)}$\\
\hline
$\mathit{CECALLM} ::=$\newline
$\mathit{m(SP):NPX} $  &
$\mathit{paramTyp(CECALLM)} = \mathit{SP}$\newline
$SR = \mathit{typ(NPX)}$\newline
$\mathit{targetTyp(NPX)} = \mathit{returnTargetTyp(CECALLM)}$\newline
$\mathit{methode(CECALLM)} = \mathit{m(SP):SR}$\\
\hline
$\mathit{CEDELM} ::=$\newline
$\mathit{m(NPX):TR} $  &
$\mathit{returnTyp(CEDELM)} = \mathit{TR} $\newline
$\mathit{TP} = \mathit{typ(NPX)} $\newline
$\mathit{targetTyp(NPX)} = \mathit{paramTargetTyp(CEDELM)} $\newline
$\mathit{methode(CEDELM)} =\mathit{m(TP):TR} $\\
\hline
\hline
\end{tabular}
\caption{Regeln und Nebenbedingungen für Contentproxies}
 \label{tab:contentAttr}
\end{table}

\subsection{ContainerTypeMatcher}
Die Matchingrelation für diesen Matcher wird durch folgende Regel beschrieben:
\begin{gather*}
\frac{\exists f:T''\in felder(T). T'' \Rightarrow_{internCont} T'}{T \Rightarrow_{container} T'}
\end{gather*}
Ein Proxy für einen Typ $P$, der mit einem Target-Typ $P'$ mit $P \Rightarrow_{container} P'$ erzeugt werden soll, ist ein \emph{Container-Proxy} und wird durch die folgenden Regeln und Nebenbedingungen beschrieben:
\begin{table}[H]
\centering
\begin{tabular}{|p{6cm}|p{8cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Nebenbedingungen} \\
\hline
\hline
$\mathit{STPROXY} ::=$\newline $\texttt{containerproxy} \texttt{ for } P$\newline
$ \texttt{with } P' \texttt{ \{} f = \mathit{NPX} \texttt{\}}$ & 
$\mathit{targetTyp(STPROXY)} = P'$\newline
$\mathit{typ(STPROXY)} = P$\newline
$P \Rightarrow_{container} P'$\newline
$\mathit{f:FT} \in \mathit{felder(P)}$\newline
$\mathit{targetTyp(NPX)} = P'$\newline
$\mathit{typ(NPX)} = FT$\\
\hline
\hline
\end{tabular}
\caption{Regeln und Nebenbedingungen für Container-Proxies}
 \label{tab:containerAttr}
\end{table}
\section{Erweiterung um einen DVMatcher}
Die o.g. Struktur für die Definition von Typen wird die Definition von \emph{provided Typen} erweitert.
\begin{table}[H]
\centering
\begin{tabular}{|p{5cm}|p{9cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Erläuterung} \\
\hline
\hline
$\mathit{PD} ::= \newline \texttt{provided } T \texttt{ extends }T' \newline \texttt{\{} \mathit{FD}\text{*} \mathit{MD}\text{*} \mathit{FCD}\text{?}\texttt{\}}$& Die Definition eines provided Typen besteht aus dem Namen des Typen \emph{T}, dem Namen des Super-Typs \emph{T'} von \emph{T} sowie mehreren Feld- und Methodendeklarationen und einer optionalen Definition eines factory Typen.\\
\hline
$\mathit{FCD} ::= \texttt{factory }T \texttt{ \{}\newline \mathit{FD}\text{*} \mathit{MD}\text{*} \texttt{\}} $& Die Definition eines factory Typen besteht aus dem Namen des Typen \emph{T} sowie mehreren Feld- und Methodendeklarationen.\\
\hline
\hline
\end{tabular}
\caption{Erweiterte Struktur für die Definition einer Bibliothek von Typen}
 \label{tab:extTDv}
\end{table}
\noindent
Darüber hinaus wird folgende Funktion definiert:
\begin{gather*}
\mathit{fabriken(T)} :=  \left\{ 
				\begin{array}{l|l}
					F & F \text{ ist ein \emph{factory Typ}, der in \emph{T} definiert wurde}
				\end{array}
              \right\}
\end{gather*}
Weiterhin muss die Struktur für die Definition von Proxies um eine weitere Definition für einen \emph{Single-Target-Proxy} erweitert werden.
\begin{table}[H]
\centering
\begin{tabular}{|p{4.5cm}|p{9.5cm}|}
\hline
\centering\textbf{Regel} & \textbf{Erläuterung} \\
\hline
\hline
$\mathit{STPROXY} ::=$\newline 
$\texttt{dvproxy }  \texttt{for } P$\newline
$\texttt{with } F \texttt{ on } \texttt{m(}\mathit{P'}\texttt{):}\mathit{P}$ & Ein \emph{DV-Proxy} ist ein Single-Target-Proxy, der für ein \emph{provided Typ P} erzeugt wird. Die Methodenaufrufe auf diesem Proxy werden an das Objekt delegiert, welches über die Methode \emph{m} des Factory-Typen \emph{F} aus dem Target-Typen \emph{P'} erzeugt wird.\\
\hline
\hline
\end{tabular}
\caption{Erweiterung der Struktur für die Definition eines Proxies}
 \label{tab:extPDv}
\end{table}
\noindent
Die Matchingrelation $\Rightarrow_{dv}$ wird über folgende Regel beschrieben:
\begin{gather*}
\frac{\exists F \in fabriken(T). \exists m(T'):T}{T \Rightarrow_{dv} T'}
\end{gather*}
Darüber hinaus müssen einige der oben beschriebenen Regeln angepasst werden, damit der \emph{ContainerTypeMatcher}, der \emph{ContentTypeMatcher} und der \emph{StructuralTypeMatcher} den \emph{DVMatcher} verwenden:
\begin{gather*}
\frac{T \Rightarrow_{exact} T' \vee T \Rightarrow_{gen} T' \vee
T \Rightarrow_{spec} T' \vee T \Rightarrow_{dv} T'  }{T \Rightarrow_{internCont} T'}
\end{gather*}
\begin{gather*}
\frac{T \Rightarrow_{internCont} T' \vee T \Rightarrow_{content} T' \vee
T \Rightarrow_{container} T'  }{T \Rightarrow_{internStruct} T'}
\end{gather*}
Ein Proxy für einen Typ $P$, der mit einem \emph{Target-Typ} $P'$ mit $P \Rightarrow_{dv} P'$ erzeugt werden soll, ist ein DV-Proxy und wird durch die folgenden Regeln und Nebenbedingungen beschrieben:
\begin{table}[H]
\centering
\begin{tabular}{|p{6cm}|p{8cm}|}
\hline
\centering\textbf{Regel} & \textbf{Nebenbedingungen} \\
\hline
\hline
$\mathit{STPROXY} ::=$\newline 
$\texttt{dvproxy }  \texttt{for } P$\newline
$\texttt{with } F \texttt{ on } \texttt{m(}\mathit{P'}\texttt{):}\mathit{P}$ 
& 
$\mathit{targetTyp(STPROXY) = P'}$\newline
$\mathit{typ(STPROXY) = P}$\newline
$\mathit{P} \Rightarrow_{dv} \mathit{P'}$\newline
$\mathit{F} \in \mathit{fabriken(P)}$\\
\hline
\hline
\end{tabular}
\caption{Regeln und Nebenbedingungen für DV-Proxies}
 \label{tab:dvAttr}
\end{table}

\end{document}
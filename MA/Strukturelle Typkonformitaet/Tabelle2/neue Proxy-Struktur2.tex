\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{float}
\usepackage{listings}
\usepackage{color}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}

\lstdefinestyle{dsl}{
	 morekeywords={with, subproxy, structproxy, for, simpleproxy, contentproxy, containerproxy, nominalproxy, provided, required, interface, extends, inject, in, posModi},
  showspaces=false,
  showtabs=false,
  breaklines=true,
   literate=
               {-->}{$\rightarrow{}$}{1}
               ,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  basicstyle=\fontsize{9}{10}\selectfont\ttfamily,
  moredelim=[il][\textcolor{pgrey}]{$ $},
  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
}




\newcommand{\matchTyp}[3]
{
#1  
\Rightarrow_{#2}
 #3
}

\begin{document}



\section{Beispiel-Bibliothek}



\begin{lstlisting}[style = dsl]
provided Fire extends Object{}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided ExtFire extends Fire{}
\end{lstlisting}


\begin{lstlisting}[style = dsl]
provided FireState extends Object{
	isActive : boolean
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided Medicine extends Object{
	String getDescription()
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided Injured extends Object{
	void heal(Medicine med)	
}
\end{lstlisting}


\begin{lstlisting}[style = dsl]
provided Patient extends Injured{
	String getName()
}
\end{lstlisting}
\begin{lstlisting}[style = dsl]
provided FireFighter extends Object{
	FireState extinguishFire(Fire fire)
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided Doctor extends Object{	
	void heal( Patient pat, Medicine med )
}
\end{lstlisting}


\begin{lstlisting}[style = dsl]
provided InverseDoctor extends Object{	
	void heal( Medicine med, Patient pat )
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
provided MedCabinet extends Object{
	med : Medicine
}
\end{lstlisting}

\begin{lstlisting}[style = dsl]
required PatientMedicalFireFighter {
	void heal( Patient patient, MedCabinet med )
	boolean extinguishFire( ExtFire fire )	
}
\end{lstlisting}

\begin{lstlisting}[caption={Bibliothek \emph{ExampLe} von Typen},captionpos=b, style = dsl]
required MedicalFireFighter {
	void heal( Injured injured, MedCabinet med )
	boolean extinguishFire( ExtFire fire )	
}
\end{lstlisting}\label{lst:libEx}

\newpage

\section{Struktur für die Definition von Proxies}\label{sec:proxygram}
Für die Konvertierung eines Typs $T$ aus einer Menge von \emph{provided Typen} $P$ wird durch Proxies beschrieben. Die Struktur eines Proxies ist Tabelle \ref{tab:grProxies} zu entnehmen.
\begin{table}[H]
\centering
\begin{tabular}{|p{5cm}|p{9cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Erläuterung} \\
\hline
\hline
$\mathit{PROXY} ::=$\newline
$\texttt{proxy } \texttt{for } T$\newline
$ \texttt{with [}\mathit{P_1},...,\mathit{P_n}\texttt{]}$ \newline
$\texttt{\{}\mathit{MDEL_1},...,\mathit{MDEL_k} \texttt{\}}$
 & Ein Proxy wird für ein Typ $T$ mit einer Mengen von \emph{provided Typen} $P = \{P_1,...,P_n\}$, einer Menge von Methoden-Delegationen erzeugt.\\
\hline
$\mathit{MDEL} ::=$\newline
$CALLM \rightarrow DELM $  & Eine Methodendelegation besteht aus einer aufgerufenen Methode und aus einem Delegationsziel.\\
\hline
$\mathit{CALLM} ::=$\newline 
$\mathit{REF}.\mathit{m(\mathit{CP_1},...,\mathit{CP_n}):CR} $  & Eine aufgerufene Methode besteht aus dem Namen der Methode \emph{m}, dem Rückgabetyp \emph{CR} und einer Menge von Parametertypen $\{\mathit{CP_1},...,\mathit{CP_n}\}$.\\
\hline
$\mathit{DELM} ::=$\newline 
$\mathit{REF}.\mathit{n(\mathit{DP_1},...,\mathit{DP_n}):DR} $  
& Die erste Variante eines Delegationsziels besteht aus  dem Namen der Methode \emph{n}, dem Rückgabetyp \emph{DR} und einer Menge von Parametertypen $\{\mathit{DP_1},...,\mathit{DP_n}\}$.\\
\hline
$\mathit{DELM} ::=$\newline
$\texttt{posModi(} \mathit{I_1},...,\mathit{I_n} \texttt{)}$\newline
$\mathit{REF}.\mathit{n(\mathit{DP_1},...,\mathit{DP_n}):DR} $  
& Die zweite Variante eines Delegationsziels besteht aus einer Menge von Indizies $\{\mathit{I_1},...,\mathit{I_n}\}$, einer Target-Referenz, dem Namen der Methode \emph{n}, dem Rückgabetyp \emph{DR} und einer Menge von Parametertypen $\{\mathit{DP_1},...,\mathit{DP_n}\}$.\\
\hline
$\mathit{DELM} ::= \texttt{err} $  
& Die dritte Variante eines Delegationsziels besteht führt zu einem Fehler, da die Delegation innerhalb des Proxies nicht möglich ist.\\
\hline
$\mathit{REF} ::= \mathit{P_i}$
& Die erste Variante einer Referenz besteht aus einem Typ $P_i$ .\\
\hline
$\mathit{REF} ::= \mathit{P_i}\texttt{.}\mathit{f}$
& Die zweite Variante einer Referenz besteht aus einem Typ $P_i$ und einem Feldnamen $f$.\\
\hline
\end{tabular}
\caption{Grammatikregeln mit Erläuterungen für die Definition eines Proxies}
 \label{tab:grProxies}
\end{table}
\noindent
Dabei handelt es sich um Produktionsregeln einer Attributgrammatik. Die dazugehörigen Attribute sind der Tabelle \ref{tab:attrGrProxies} zu entnehmen. dazu sei zusätzlich festgelegt, dass die Notation $\mathit{NT}\texttt{.}\text{*}$ in der Spalte \emph{Attribute} eine Key-Value-Liste aller Attribute des Nonterminals $\mathit{NT}$ beschreibt, wobei der Attributname als Key und dessen Wert als Value innerhalb der List verwendet wird. Weiterhin sei ein Attribut, dass in der Spalte \emph{Attribute} zu einem Nonterminal nicht aufgeführt ist, wird mit dem Wert \emph{none} belegt.
\begin{table}[H]
\centering
\begin{tabular}{|p{6cm}|p{8cm}|}
\hline
\hline
\centering\textbf{Regel} & \textbf{Attribute} \\
\hline
\hline
$\mathit{PROXY} ::=$\newline
$\texttt{proxy } \texttt{for } T$\newline
$ \texttt{with [}\mathit{P_1},...,\mathit{P_n}\texttt{]}$ \newline
$\texttt{\{}\mathit{MDEL_1},...,\mathit{MDEL_k} \texttt{\}}$
& 
$\texttt{type} = \mathit{T}$\newline
$\texttt{targets} = [\mathit{P_1},...,\mathit{P_n}]$\newline
$\texttt{dels} = [\mathit{MDEL_1}\texttt{.}\text{*},...,\mathit{MDEL_k}\texttt{.}\text{*}]$
\\
\hline
$\mathit{MDEL} ::=$\newline
$\mathit{CALLM} \rightarrow \mathit{DELM} $  
& 
$\texttt{call} = \mathit{CALLM}.*$\newline
$\texttt{del} = \mathit{DELM}.*$
\\
\hline
$\mathit{CALLM} ::=$\newline 
$\mathit{REF}.\mathit{m(\mathit{CP_1},...,\mathit{CP_n}):CR}$
& 
$\texttt{source} = \mathit{REF.\texttt{mainType}}$\newline
$\texttt{delType} = \mathit{REF.\texttt{delType}}$\newline
$\texttt{name} = \mathit{m}$\newline
$\texttt{paramTypes} = \mathit{[CP_1},...,\mathit{CP_n]}$\newline
$\texttt{returnType} = \mathit{CR}$\newline
$\texttt{field} = \mathit{REF}\texttt{.field}$
\\
\hline
$\mathit{DELM} ::=$\newline 
$\mathit{REF}\texttt{.}n(\mathit{DP_1},...,\mathit{DP_n}):DR $  
&
$\texttt{target} = \mathit{REF}.\texttt{mainType}$\newline
$\texttt{delType} = \mathit{REF}.\texttt{delType}$\newline
$\texttt{posModi} = [0,...,\mathit{n}-1]$\newline
$\texttt{name} = \mathit{n}$\newline
$\texttt{paramTypes} = \mathit{[DP_1},...,\mathit{DP_n]}$\newline
$\texttt{returnType} = \mathit{DR}$\newline
$\texttt{field} = \mathit{REF}\texttt{.field}$
\\
\hline
$\mathit{DELM} ::=\texttt{posModi(} \mathit{I_1},...,\mathit{I_n} \texttt{)}$\newline
$\mathit{REF}\texttt{.}n(\mathit{DP_1},...,\mathit{DP_n}):DR $  
&
$\texttt{target} = \mathit{REF}.\texttt{mainType}$\newline
$\texttt{delType} = \mathit{REF}.\texttt{delType}$\newline
$\texttt{posModi} = \mathit{[I_1},...,\mathit{I_n]}$\newline
$\texttt{name} = \mathit{n}$\newline
$\texttt{paramTypes} = \mathit{[DP_1},...,\mathit{DP_n]}$\newline
$\texttt{returnType} = \mathit{DR}$\newline
$\texttt{field} = \mathit{REF}\texttt{.field}$
\\
\hline
$\mathit{DELM} ::= \texttt{err} $  
&
\\
\hline
$\mathit{REF} ::= \mathit{P}$
& 
$\texttt{mainType} = \mathit{P}$\newline
$\texttt{field} = \texttt{self}$\newline
$\texttt{delType} = \mathit{P}$
\\
\hline
$\mathit{REF} ::= \mathit{P}\texttt{.}\mathit{f}$
&
$\texttt{mainType} = \mathit{P}$\newline
$\texttt{field} = \mathit{f}$\newline
$\texttt{delType} = \mathit{feldTyp(f,P)}$
\\
\hline
\end{tabular}
\caption{Grammatikregeln mit Attributen für die Definition eines Proxies}
 \label{tab:attrGrProxies}
\end{table}

\newpage
\section{Generierung der Proxies auf Basis von Matchern}
Die Matcher beinhalten die Definition der jeweiligen Matchingrelation ($\Rightarrow$). Auf deren Basis werden Proxies für bestimmte Typen erzeugt. Dabei gibt es unterschiedliche Arten von Proxies. Jede Proxy-Art basiert auf einem anderen Matcher.\\\\
Die Proxies haben eine allgemeine Struktur, die in Abschnitt \ref{sec:proxygram} aufgeführt ist. Um die Regeln für die Generierung der Proxies zu beschreiben, soll davon ausgegangen werden, dass jedes Listen-Attribut aus Tabelle \ref{tab:attrGrProxies} ein Attribut $\texttt{len}$ enthält in dem die Anzahl der in der Liste befindlichen Elemente abgelegt ist.





%\subsection{Generierung der Proxies}
%Zum besseren Verständnis werden die Regeln zur Generierung der Proxies auf das Beispiel aus Abschnitt \ref{xmpl_prxy} angewendet. Da die Proxies verschachtelt sind, erfolgt die beispielhafte Generierung in den folgenden Abschnitten schrittweise parallel zur Beschreibung der Generatoren.
%\begin{itemize}
%\item \emph{Struktureller Proxy}
%\item \emph{Simple-Proxy}
%\item \emph{Sub-Proxy}
%\item \emph{Container-Proxy}
%\item \emph{Content-Proxy}
%\end{itemize}


\begin{table}[H]
\centering
\begin{tabular}{|p{5cm}|p{5cm}|}
\hline
\hline
\centering\textbf{Proxy-Art} & \textbf{Basis-Matchingrelation} \\
\hline
\hline
Sub-Proxy
&  
$\Rightarrow_{spec}$
\\
\hline
Content-Proxy
& 
$\Rightarrow_{content}$
\\
\hline
Container-Proxy
& 
$\Rightarrow_{container}$
\\
\hline
struktureller Proxy
&
$\Rightarrow_{struct}$ \\
\hline
\hline
\end{tabular}
\caption{Proxy-Arten und die dazugehörigen Basis-Matchingrelationen}
 \label{tab:baseMatcher}
\end{table}

\subsubsection{Sub-Proxy}

Die Voraussetzung für die Erzeugung eines \emph{Sub-Proxies} vom Typ $T$ aus einem Target-Typ $T'$ ist $T \Rightarrow_{spec} T'$. Damit ist der \emph{SpecTypeMatcher} der Basis-Matcher für den Sub-Proxy.\\\\
Als Beispiel soll hierfür der Typ $\texttt{Patient}$ als Source-Typ der Proxies und der Typ $\texttt{Injured}$ als Target-Typ verwendet werden. Da $\texttt{Patient} \Rightarrow_{spec} \texttt{Injured}$ gilt, kann ein \emph{Sub-Proxy} für diese Konstellation erzeugt werden. Der resultierende \emph{Sub-Proxy} ist im folgenden Listing aufgeführt.
\begin{lstlisting}[style = dsl]
proxy for Patient with [Injured]{
	Patient.heal(Medicine):void --> Injured.heal(Medicine):void
	Patient.getName():String --> err
}
\end{lstlisting}
Der abstrakte Syntaxbaum mit den dazugehörigen Attributen ist folgender Abbildung zu entnehmen. \footnote{Es wurden nur die Nonterminale mit den dazugehörigen Attributen aufgeführt.}
\begin{figure}

\end{figure}

Wird der Proxy als Typ verwendet, so stehen darin alle Methoden zur Verfügung, die auch im Typ $\texttt{Patient}$ zur Verfügung stehen. Die Methodendelegationen innerhalb dieses Proxies, beschreiben, was beim Aufruf der jeweiligen aufgerufenen Methoden passiert. So wird ein Aufruf der Methode $\texttt{heal}$ an die Methode $\texttt{heal}$ aus dem Target-Typ delegiert. Ein Aufruf der Methode $\texttt{getName}$ hingegen führt zu einem Fehler, weil keine Delegationsmethode zur Verfügung steht.\\\\
In Hinblick darauf, dass eine Konvertierung von einem Super-Typ und einen Sub-Typ (Down-Cast) ebenfalls dazu führt, dass bestimmte Methoden, wie in diesem Fall $\texttt{getName}$ nicht ausgeführt werden kann, spiegelt der \emph{Sub-Proxy} dieses Verhalten wieder.\\\\
Formal wird ein \emph{Sub-Proxy} durch die Regeln beschrieben, die im Folgenden vorgestellt werden.
Ein \emph{Sub-Proxy} enthält genau einen Target-Typ. Für einen Proxy $P$ wird dieser Sachverhalt durch die folgende Regel dargestellt.
\begin{gather*}
\frac{|P.targets| = 1 \wedge P.targets[0] = T'}{\mathit{singleTarget(T')}}
\end{gather*}
Darüber hinaus enthält ein \emph{Sub-Proxy} $P$ eine bestimmte Menge von Methoden-Delegationen. Dabei muss das Attribut $\texttt{field}$ sowohl in den aufgerufenen Methoden und in den Delegationsmethoden aller Methodendelegationen jeweils übereinstimmen. Folgende Regel stellt diesen Sachverhalt für eine Menge von Methodendelegationen $\mathit{MDEL}$ dar.
\begin{gather*}
\frac{\splitfrac{\forall \mathit{DEL_1}\in \mathit{MDEL}. \neg(\exists \mathit{DEL_2} \in \mathit{MDEL}.DEL_1.call.field \neq DEL_2.call.field}{ \vee DEL_1.del.field \neq DEL_2.del.field )}}
{\mathit{equalRefs(MDEL)}}
\end{gather*}
Für jede einzelne Methoden-Delegation gilt weiterhin, dass die aufgerufenen Methode und die Delegationsmethode denselben Namen haben.
\begin{gather*}
\frac{\mathit{DEL.call.name} = \mathit{DEL.del.name}}
{\mathit{nominalDel(DEL)}}
\end{gather*}
Die aufgerufene Methode muss dabei generell im Typ aus dem Attribut $call.declType$ deklariert sein und die Delegationsmethode im Typ aus dem Attribut $del.declType$.
\begin{gather*}
\frac{\exists m(P_1,...,P_n):R \in \mathit{methoden(DEL.call.declType)}. \mathit{DEL.call.name} = m}
{\mathit{simpleCallMethod(DEL, P)}}
\end{gather*}
\begin{gather*}
\frac{\exists m(P_1,...,P_n):R \in \mathit{methoden(DEL.del.declType)}. \mathit{DEL.del.name} = m}
{\mathit{simpleDelMethod(DEL, P)}}
\end{gather*}
Zusätzlich muss das Attribut $\texttt{field}$ sowohl im Attribut $call$ mit dem Wert $\texttt{self}$ belegt und das Attribut $\texttt{mainType}$ mit dem Typ des Proxies belegt sein.
\begin{gather*}
\frac{\mathit{DEL.call.mainType} = \mathit{P.type} \wedge \mathit{DEL.call.field} = \mathit{self}}
{\mathit{simpleDelSource(DEL, P)}}
\end{gather*}
Damit ist auch gewährleistet, dass die Attribute $\texttt{mainType}$ und $\texttt{delType}$ im Attribut $\texttt{call}$ übereinstimmen.\\\\
Ähnliches gilt für die Attribute $\texttt{field}$ und $\texttt{mainType}$ im Attribut $del$. Hierbei muss der Wert des Attributs $\texttt{mainType}$ jedoch mit dem Target-Typ des Proxies übereinstimmen.
\begin{gather*}
\frac{\mathit{DEL.del.mainType} = \mathit{P.targets[0]}\wedge \mathit{DEL.del.field} = \mathit{self}}
{\mathit{simpleDelTarget(DEL, P)}}
\end{gather*}
Damit ist wiederum gewährleistet, dass die Attribute $\texttt{mainType}$ und $\texttt{delType}$ im Attribut $\texttt{del}$ übereinstimmen.\\\\
Die Regeln bzgl. der linken Seite einer Methoden-Delegation innerhalb eines \emph{Sub-Proxies} können damit in folgender Regel zusammengefasst werden:
\begin{gather*}
\frac{\mathit{simpleCallMethod(DEL,P)} \wedge \mathit{simpleDelSource(DEL,P)}}
{simpleCall(DEL,P)}
\end{gather*}
Analog dazu können auch die Regeln bzgl. der rechten Seite einer Methoden-Delegation innerhalb eines \emph{Sub-Proxies} zusammengefasst werden:
\begin{gather*}
\frac{\mathit{simpleDelMethod(DEL,P)} \wedge \mathit{simpleDelTarget(DEL,P)}}
{simpleDel(DEL,P)}
\end{gather*}
Jedoch ist im \emph{Sub-Proxy} die Ausnahme zu beachten:
\begin{gather*}
\frac{\mathit{DEL.del.name} = \mathit{none}}
{\mathit{errDel(DEL)}}
\end{gather*}
In diesem Fall würden die o.g. Kriterien nicht gelten. Die genannten Regeln bzgl. einer Methoden-Delegation in einem \emph{Sub-Proxy} lassen sich über beiden folgenden Regeln beschreiben:
\begin{gather*}
\frac{\mathit{simpleCall(DEL,P)} \wedge \mathit{simpleDel(DEL,P) \wedge \mathit{nominalDel(DEL)}}}
{subDelegation(DEL,P)}
\end{gather*}
\begin{gather*}
\frac{\mathit{simpleCall(DEL,P)}\wedge\mathit{errDel(DEL)}
}
{subMDEL(DEL,P)}
\end{gather*}
Innerhalb eines \emph{Sub-Proxies} gibt es für jede Methode $m$ des Source-Typ genau eine Methoden-Delegation, mit der Methode $m$ als aufgerufene Methode. Damit lässt sich für einen Proxy $P$ in Bezug auf seine Methoden-Delegationen folgende Regeln formulieren:
\begin{gather*}
\frac{\splitfrac{|\mathit{methoden(P.type)}| = |P.dels| \wedge}{ \splitfrac{\forall m(P_1,...,P_n):R \in \mathit{methoden(P.type)}.\exists DEL \in P.dels.}{m = \mathit{DEL.call.name} \wedge \mathit{subMDEL(DEL,P)}
 }}
}
{subMDELList(P)}
\end{gather*}
Die Menge der \emph{Sub-Proxies}, die mit dem Source-Typ $T$ und dem Target-Typ $T'$ erzeugt werden, wird durch die folgende Funktion beschrieben.
\begin{gather*}
\mathit{proxies_{sub}(T,T')} := 
\left\{\begin{array}{l|l}
	P	& P\texttt{.type} = T \wedge  \mathit{singleTarget(T')} \wedge \mathit{ }\\
		& \mathit{equalRefs(P.dels)} \wedge \mathit{subMDELList(P)}
		 \end{array}
\right\}
\end{gather*}


\subsubsection{Content-Proxy}
Die Voraussetzung für die Erzeugung eines \emph{Content-Proxies} vom Typ $T$ aus einem Target-Typ $T'$ ist $T \Rightarrow_{content} T'$. Damit ist der \emph{ContentTypeMatcher} der Basis-Matcher für den \emph{Content-Proxy}.\\\\
Als Beispiel können hierfür die Typen $\texttt{Medicine}$ und $\texttt{MedCabinet}$ verwendet werden. Diese weisen ein Matching der Form $texttt{Medicine} \Rightarrow_{content} texttt{MedCabinet}$ auf. Daher kann ein \emph{Content-Proxy} für diese Konstellation erzeugt werden. Ein resultierender \emph{Content-Proxy} ist in folgendem Listing aufgeführt.
\begin{lstlisting}[style = dsl]
proxy for Medicine with [MedCabinet]{
	Medicine.getDesciption():String --> MedCabinet.med.getDesciption():String
}
\end{lstlisting}
Durch die Methoden-Delegation dieses \emph{Content-Proxies} wird die Methode $\texttt{getDescription}$ an das Feld $\texttt{med}$ des Target-Typen $\texttt{MedCabniet}$ delegiert.\\\\
Der abstrakte Syntaxbaum mit den dazugehörigen Attributen ist folgender Abbildung zu entnehmen. \footnote{Es wurden nur die Nonterminale mit den dazugehörigen Attributen aufgeführt.}
\begin{figure}

\end{figure}

Formal wird ein \emph{Content-Proxy} durch die Regeln beschrieben, die im Folgenden vorgestellt werden.\\\\
Ein \emph{Content-Proxy} enthält, wie auch der \emph{Sub-Proxy}, genau einen Target-Typ. Ebenfalls identisch zum \emph{Sub-Proxy} sind die Bedingungen hinsichtlich der aufgerufenen Methoden in den einzelnen Methoden-Delegationen.\\\\
In den Delegationsmethoden einer einzelnen Methoden-Delegation darf das Attribut $\texttt{mainType}$ und $\texttt{delType}$ im \emph{Content-Proxy} nicht identisch sein. Dementsprechend darf das Attribut $\texttt{field}$ nicht mit dem Wert $\texttt{self}$ belegt sein. Vielmehr muss für das Attribut $\texttt{delTyp}$ und den Source-Typ $T$ im Attribut $\texttt{type}$ des Proxies ein Matching der Form $T \Rightarrow_{internCont} \texttt{delTyp}$ gelten. Daher gilt für den \emph{Content-Proxy} folgende Regel.
\begin{gather*}
\frac{\mathit{DEL.del.mainType} = \mathit{P.targets[0]} \wedge \mathit{P.type} \Rightarrow_{internCont} \mathit{DEL.del.delType}}
{\mathit{contentDelTarget(DEL,P)}}
\end{gather*}
\noindent
Damit ist auch die zusammenfassende Regel für die Delegationsmethoden eine andere:
\begin{gather*}
\frac{\mathit{simpleDelMethod(DEL,P)} \wedge \mathit{contentDelTarget(DEL,P)}}
{contentDel(DEL,P)}
\end{gather*}
Die zusammenfassende Regel für eine einzelne Methoden-Delegation innerhalb eines \emph{Content-Proxies} hat die folgende Form:
\begin{gather*}
\frac{\mathit{simpleCall(DEL,P)} \wedge \mathit{contentDel(DEL,P) \wedge \mathit{nominalDel(DEL)}}}
{contentMDEL(DEL,P)}
\end{gather*}
Wie auch im \emph{Sub-Proxy} gibt es im \emph{Content-Proxy} für jede Methode $m$ des Source-Typen genau eine Methoden-Delegation mit der Methode $m$ als aufgerufene Methode. Daraus ergibt sich für alle Methoden-Delegationen aus einem \emph{Content-Proxy} $P$ folgende Regel:
\begin{gather*}
\frac{\splitfrac{|\mathit{methoden(P.type)}| = |P.dels| \wedge}{ \splitfrac{\forall m(P_1,...,P_n):R \in \mathit{methoden(P.type)}.\exists DEL \in P.dels.}{m = \mathit{DEL.call.name} \wedge \mathit{contentMDEL(DEL,P)}
 }}
}
{contentMDELList(P)}
\end{gather*}
Die Menge der \emph{Content-Proxies}, die mit dem Source-Typ $T$ und dem Target-Typ $T'$ erzeugt werden, wird durch die folgende Funktion beschrieben.
\begin{gather*}
\mathit{proxies_{content}(T,T')} := 
\left\{\begin{array}{l|l}
	P	& P\texttt{.type} = T \wedge  \mathit{singleTarget(T')} \wedge \mathit{ }\\
		& \mathit{equalRefs(P.dels)} \wedge \mathit{contentMDELList(P)} 
		 \end{array}
\right\}
\end{gather*}
\subsubsection{Container-Proxy}
Die Voraussetzung für die Erzeugung eines \emph{Container-Proxies} vom Typ $T$ aus einem Target-Typ $T'$ ist $T \Rightarrow_{container} T'$. Damit ist der \emph{ContainerTypeMatcher} der Basis-Matcher für den \emph{Container-Proxy}.\\\\
Als Beispiel können hierfür wiederum die Typen $\texttt{Medicine}$ und $\texttt{MedCabinet}$ verwendet werden. Diese weisen ein Matching der Form $\texttt{MedCabinet} \Rightarrow_{container} \texttt{Medicine}$ auf. Daher kann ein \emph{Content-Proxy} für diese Konstellation erzeugt werden. Ein resultierender \emph{Content-Proxy} ist in folgendem Listing aufgeführt.
\begin{lstlisting}[style = dsl]
proxy for MedCabinet with [Medicine]{
	MedCabinet.med.getDesciption():String --> Medicine.getDesciption():String
}
\end{lstlisting}
Durch die Methoden-Delegation dieses \emph{Container-Proxies} findet eine Delegation nur dann statt, wenn die Methoden $\texttt{getDescription}$ auf dem Feld $\texttt{med}$ des Source-Typ aufgerufen wird. Diese wird dann an den Target-Typen $\texttt{MedCabniet}$ delegiert.\\\\
Der abstrakte Syntaxbaum mit den dazugehörigen Attributen ist folgender Abbildung zu entnehmen. \footnote{Es wurden nur die Nonterminale mit den dazugehörigen Attributen aufgeführt.}
\begin{figure}

\end{figure}

Formal wird ein \emph{Container-Proxy} durch die Regeln beschrieben, die im Folgenden vorgestellt werden.\\\\
Ein \emph{Container-Proxy} enthält, wie die vorher beschriebenen Proxies , genau einen Target-Typ. Die Eigenschaften der einzelnen Delegationsmethoden gleichen denen aus dem \emph{Sub-Proxy}.\\\\
In den angerufenen Methoden einer einzelnen Methoden-Delegation dürfen die Attribute $\texttt{mainType}$ und $\texttt{delType}$ im \emph{Container-Proxy} nicht übereinstimmen. Dementsprechend darf das Attribut $\texttt{field}$ nicht mit dem Wert $\texttt{self}$ belegt sein. Vielmehr muss für das Attribut $\texttt{delTyp}$ und den Target-Typ $T$ ein Matching der Form $T \Rightarrow_{internCont} \texttt{delTyp}$ gelten. Daher gilt für den \emph{Container-Proxy} folgende Regel.
\begin{gather*}
\frac{\mathit{DEL.call.mainType} = \mathit{P.type} \wedge \mathit{P.targets[0]} \Rightarrow_{internCont} \mathit{DEL.call.delType}}
{\mathit{containerDelSource(DEL,P)}}
\end{gather*}
\noindent
Damit ist auch die zusammenfassende Regel für die aufgerufenen Methoden eine andere:
\begin{gather*}
\frac{\mathit{simpleCallMethod(DEL,P)} \wedge \mathit{containerDelSource(DEL,P)}}
{containerCall(DEL,P)}
\end{gather*}
Die zusammenfassende Regel für eine einzelne Methoden-Delegation innerhalb eines \emph{Container-Proxies} hat die folgende Form:
\begin{gather*}
\frac{\mathit{containerCall(DEL,P)} \wedge \mathit{simpleDel(DEL,P) \wedge \mathit{nominalDel(DEL)}}}
{containerMDEL(DEL,P)}
\end{gather*}
Für einen \emph{Container-Proxy} $P$ gilt ebenfalls die Regel $\mathit{equalRefs(P.dels)}$. Daher müssen die Werte des Attributs $\texttt{call.delType}$ aller Methoden-Delegationen des Proxies $P$ übereinstimmen. Ferner muss es für jede Methode $m$ des Typen aus $\texttt{call.delType}$ genau eine Methoden-Delegation mit der Methode $m$ als aufgerufene Methode. Daraus ergibt sich für alle Methoden-Delegationen aus einem \emph{Content-Proxy} $P$ folgende Regel:
\begin{gather*}
\frac{\splitfrac{|\mathit{methoden(P.dels[0].call.delType)}| = |P.dels| \wedge}{ \splitfrac{\forall m(P_1,...,P_n):R \in \mathit{methoden(P.dels[0].call.delType)}.}{\exists DEL \in P.dels.m = \mathit{DEL.call.name} \wedge \mathit{containerMDEL(DEL,P)}
 }}
}
{\mathit{containerMDELList(P)}}
\end{gather*}
Die Menge der \emph{Container-Proxies}, die mit dem Source-Typ $T$ und dem Target-Typ $T'$ erzeugt werden, wird durch die folgende Funktion beschrieben.
\begin{gather*}
\mathit{proxies_{container}(T,T')} := 
\left\{\begin{array}{l|l}
	P	& P\texttt{.type} = T \wedge  \mathit{singleTarget(T')} \wedge \mathit{ }\\
		& \mathit{equalRefs(P.dels)} \wedge \mathit{containerMDELList(P)} 
		 \end{array}
\right\}
\end{gather*}

\subsubsection{Struktureller Proxy}
Ein struktureller Proxy wird für einen \emph{required Typ} $T$ erzeugt. Als Basis für diesen Proxy-Generator fungiert der \emph{StructuralTypeMatcher}.\\\\
Für die Generierung eines solchen Proxies vom Typ $T$ muss sichergestellt werden, dass alle in $T$ enthaltenen
Methoden durch ein oder mehrere \emph{provided Typen} innerhalb der gesamten Bibliothek $L$ gematcht werden. Die folgende Funktion $\mathit{cover}$ beschreibt daher eine Menge von Mengen von \emph{provided Typen}, die für die Erzeugung eines \emph{strukturellen Proxies} für $T$ verwendet werden können.
\begin{gather*}
cover(T,L) := 
\left\{\begin{array}{l|l}
					& P_1 \in L \wedge \text{...} \wedge P_n \in L \wedge \\
					& methoden(T) = structM(T,P_1) \cup \\
	\{P_1,...,P_n\}	& \texttt{...} \cup structM(T, P_n) \wedge \\
					& \mathit{structM(T,P_1)} \neq \emptyset \wedge \\
					& \texttt{...}\wedge \mathit{structM(T,P_n)} \neq \emptyset 
\end{array}\right\}
\end{gather*}
Ausgehend von einer Bibliothek $L$ kann ein \emph{strukureller Proxy} zum \emph{require Typ} $T$ aus einer Menge von \emph{provided Typen} $P$ mit $P \in \mathit{cover(T,L)}$ generiert werden.

\end{document}